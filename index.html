<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7.3 - Long-only | Stage Lights + Ignite->AI</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#050505; color:#d4d4d8; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .card { background:#0f0f11; border:1px solid #1f1f23; }
    .pill { border:1px solid #2a2a31; background:#0b0b0d; }
    .muted { color:#71717a; }
    .mono { font-variant-numeric: tabular-nums; }
    .ok { color:#22c55e; }
    .bad { color:#ef4444; }
    .warn { color:#f59e0b; }
    .badge { border:1px solid #2a2a31; background:#0b0b0d; padding:2px 8px; border-radius:999px; font-size:11px; }
    .locked { border:2px solid rgba(34,197,94,0.55) !important; box-shadow: 0 0 18px rgba(34,197,94,0.14); }
    .top1 { border:2px solid rgba(59,130,246,0.55) !important; box-shadow: 0 0 18px rgba(59,130,246,0.12); }

    .stage-setup { color:#f59e0b; border-color:#f59e0b !important; }
    .stage-ignite { color:#fb923c; border-color:#fb923c !important; }
    .stage-confirm{ color:#22c55e; border-color:#22c55e !important; }

    .btn { padding: 8px 12px; border-radius: 8px; font-size:12px; font-weight:800; }
    .btn-dark { background:#111115; border:1px solid #2a2a31; color:#cbd5e1; }
    .btn-dark:hover { background:#1a1a20; }
    .btn-blue { background:#2563eb; color:white; }
    .btn-blue:hover { background:#3b82f6; }
    .btn-green { background:#047857; color:white; }
    .btn-green:hover { background:#059669; }
  </style>
</head>

<body class="p-4">

  <!-- Top bar -->
  <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between mb-4">
    <div class="flex items-center gap-3">
      <span id="hb" class="inline-block w-2 h-2 rounded-full bg-zinc-600"></span>
      <div>
        <div class="text-white font-black italic text-xl leading-none">
          TRIDENT <span class="text-emerald-400">V7.3</span> <span class="text-zinc-500 text-sm font-bold">LONG ONLY</span>
        </div>
        <div class="text-[11px] muted">
          ğŸŸ¨è“„å‹¢ / ğŸŸ§é»ç«(çºŒåŠ›) / ğŸŸ©è§¸ç™¼ï½œçºŒåŠ›æ‰å• AIï½œTop5 å‡çµé˜²è·³ï½œWS ä¸»å‹•è²·å…¥å·®é¡/æ¯”ä¾‹
        </div>
        <div id="status" class="text-[11px] muted mono mt-1">status: -</div>
      </div>
    </div>

    <div class="flex flex-col md:flex-row gap-2 md:items-end">
      <div class="flex gap-2 items-center">
        <input id="geminiKey" type="password" placeholder="Gemini API Keyï¼ˆåªå­˜æœ¬æ©Ÿ localStorageï¼‰"
               class="w-80 max-w-full px-3 py-2 rounded text-[12px] bg-zinc-900 border border-zinc-700 text-white outline-none" />
        <button id="saveKeyBtn" class="btn btn-dark">Save</button>
        <button id="clearKeyBtn" class="btn btn-dark">Clear</button>
      </div>

      <div class="flex gap-2 items-center">
        <button id="autoAiBtn" class="btn btn-dark">Auto AI: OFF</button>
        <button id="testGeminiBtn" class="btn btn-green">Test Gemini</button>
        <button id="analyzeBtn" class="btn btn-blue">åˆ†æ Topï¼ˆæ‰‹å‹•ï¼‰</button>
        <button id="resetBtn" class="btn btn-dark">RESET</button>
      </div>
    </div>
  </div>

  <!-- Main -->
  <div class="card rounded-lg p-4">
    <div class="flex items-center justify-between mb-3">
      <div class="text-white font-black">Top 5ï¼ˆä»¥ã€Œå™´å‰ã€å„ªå…ˆæ’åºï¼‰</div>
      <div class="text-[11px] muted mono">
        æ›´æ–°ï¼š<span id="lastUpdate">-</span>
        Â· å‡çµï¼š<span id="freeze">-</span>
        Â· LOCKï¼š<span id="lockUI">-</span>
        Â· æ¨¡å‹ï¼š<span id="modelName">-</span>
        Â· max_out=<span id="maxOut">-</span>
        Â· AIè§¸ç™¼=ğŸŸ§é»ç«æŒçºŒ<span id="igniteHold">-</span>s
      </div>
    </div>
    <div id="top5" class="flex flex-col gap-3"></div>
  </div>

<script>
/* =========================================================
   CONFIG
========================================================= */
const CFG = {
  EXCLUDE: new Set(['BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','BNBUSDT','BNXUSDT']),

  // anomaly-first
  VOL_Z_TH: 1.6,
  FUND_Z_TH: 1.0,
  CANDIDATE_MAX: 40,
  WATCH_POOL_MAX: 12,            // åªç›£æ§å°‘é‡ï¼Œé¿å…å‰ç«¯éé‡

  // anti-chase
  MAX_RET_5M_PCT: 0.9,
  MAX_ABS_PREMIUM_PCT: 0.25,

  // robust z requires some history
  ROBUST_MIN_HIST: 6,

  // live flow window
  FLOW_BUCKET_MS: 3000,
  FLOW5M_MS: 5 * 60 * 1000,
  FLOW4H_MS: 4 * 60 * 60 * 1000,
  FLOW_SAMPLE_MS: 15000,
  FLOW_HIST_LEN: 240,            // 60 min history (240*15s)

  // OI
  OI_REFRESH_MS: 60_000,

  // long-only gate
  LONG_FLOW_IMB_MIN: 0.03,       // åŸºç¤åå¤š
  LONG_REQUIRE_OI_POS: false,

  // stable ranking
  RANK_FREEZE_MS: 60_000,
  RANK_REPLACE_RATIO: 1.12,
  RANK_REPLACE_ABS: 0.8,

  // strongest lock
  LOCK_MIN_HOLD_MS: 90_000,
  LOCK_SWITCH_RATIO: 1.06,
  LOCK_SWITCH_ABS: 1.0,

  // stage lights (ä¸­ç­‰æ•æ„Ÿ)
  STAGE: {
    SETUP: {
      TO_HIGH_MIN: 0.05, TO_HIGH_MAX: 0.80,
      RET5M_MIN: -0.20, RET5M_MAX: 0.40,
      IMB5M_MIN: 0.03,
      DELTA5M_POS: true,
      SQUEEZE_MIN: 0.70
    },
    IGNITE: {
      DELTAZ_MIN: 2.0,
      DELTAZ_VEL_MIN: 0.08,     // ä»¥ 15s æ¨™æº–åŒ–çš„åŠ é€Ÿåº¦é–€æª»ï¼ˆä¸­ç­‰ï¼‰
      IMB5M_MIN: 0.08,
      VOL5MZ_MIN: 1.2,
      TO_HIGH_MIN: 0.03,
      RET5M_MAX: 0.60
    },
    CONFIRM: {
      VOL1M_RATIO_MIN: 2.0,
      CLOSE_ABOVE_HIGH_BP: 2,   // 2 bps = 0.02% buffer
      IMB5M_MIN: 0.05
    },
    HOLD_MS: { NONE:0, SETUP: 90_000, IGNITE: 120_000, CONFIRM: 180_000 }
  },

  // Gemini
  GEMINI: {
    MODEL: "gemini-2.5-flash",
    MAX_OUTPUT_TOKENS: 480,
    TEMP: 0.2,

    // ä½ ç¾åœ¨å¯èƒ½é‚„æ˜¯æœƒé‡åˆ°é…é¡ï¼Œé€™äº›æ˜¯å®‰å…¨é–¥ï¼ˆèª²é‡‘å¾Œå¯èª¿é«˜ï¼‰
    RPM_LIMIT: 5,
    RPD_LIMIT: 20,
    RPD_SOFT_CAP: 18,           // ç•™é¡åº¦çµ¦ä½ æ‰‹å‹•æŒ‰
    MIN_INTERVAL_MS: 12_500,    // >= 60/5 ç§’
    BACKOFF_429_MS: 10 * 60 * 1000,

    SYMBOL_COOLDOWN_MS: 5 * 60 * 1000,

    // âœ… çºŒåŠ›æ‰è¨ªå• AIï¼šåªæœ‰ ğŸŸ§IGNITE ä¸”æŒçºŒ >= N ç§’æ‰è‡ªå‹•å•
    AUTO_ENABLED: false,
    AUTO_POLL_MS: 10_000,
    AUTO_TRIGGER_STAGE: "IGNITE",
    AUTO_TRIGGER_HOLD_MS: 35_000,  // ğŸ”¥ çºŒåŠ›é–€æª»ï¼ˆä½ å¯æ”¹ 20~60 ç§’ï¼‰
    AUTO_ONLY_LOCKED: true         // åªå•æœ€å¼·é–å®šï¼ˆå»ºè­°ï¼‰
  }
};

document.getElementById('modelName').innerText = CFG.GEMINI.MODEL;
document.getElementById('maxOut').innerText = CFG.GEMINI.MAX_OUTPUT_TOKENS;
document.getElementById('igniteHold').innerText = Math.round(CFG.GEMINI.AUTO_TRIGGER_HOLD_MS/1000);

/* =========================================================
   UTILS
========================================================= */
class Ring {
  constructor(n){ this.n=n; this.a=[]; this.i=0; }
  push(x){
    if (this.a.length < this.n) this.a.push(x);
    else { this.a[this.i] = x; this.i = (this.i+1) % this.n; }
  }
  values(){
    if (this.a.length < this.n || this.i===0) return this.a.slice();
    return this.a.slice(this.i).concat(this.a.slice(0,this.i));
  }
  get size(){ return this.a.length; }
  last(){
    if (!this.a.length) return null;
    if (this.a.length < this.n) return this.a[this.a.length-1];
    const idx = (this.i - 1 + this.n) % this.n;
    return this.a[idx];
  }
}
function median(arr){
  if (!arr.length) return 0;
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}
function mad(arr, med){
  if (!arr.length) return 0;
  const dev = arr.map(x=>Math.abs(x - med));
  return median(dev);
}
function robustZ(x, hist){
  if (!hist || hist.length < CFG.ROBUST_MIN_HIST) return null;
  const med = median(hist);
  const m = mad(hist, med) || 1e-12;
  return (x - med) / (1.4826*m);
}
function linSlope(y){
  const n = y.length;
  if (n < 6) return 0;
  let sx=0, sy=0, sxx=0, sxy=0;
  for (let i=0;i<n;i++){ sx+=i; sy+=y[i]; sxx+=i*i; sxy+=i*y[i]; }
  const den = n*sxx - sx*sx;
  if (Math.abs(den) < 1e-12) return 0;
  return (n*sxy - sx*sy) / den;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function fmt(x, d=3){
  if (x===null || x===undefined || Number.isNaN(x)) return '-';
  const v = Number(x);
  if (!Number.isFinite(v)) return '-';
  return v.toFixed(d);
}
function fmtInt(x){
  if (x===null || x===undefined || Number.isNaN(x)) return '-';
  const v = Number(x);
  if (!Number.isFinite(v)) return '-';
  return Math.round(v).toString();
}
function pct(x, d=2){ return fmt(x, d) + '%'; }
function nowMs(){ return Date.now(); }
function escapeHtml(s){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}
function hashStr(s){
  let h=2166136261;
  for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return (h>>>0).toString(16);
}

/* =========================================================
   Live Flow Window (bucketed)
========================================================= */
class BucketWindow {
  constructor(windowMs, bucketMs){
    this.windowMs = windowMs;
    this.bucketMs = bucketMs;
    this.q = []; // {t,buy,sell}
    this.sumBuy = 0;
    this.sumSell = 0;
  }
  _prune(now){
    const minT = now - this.windowMs;
    while (this.q.length && this.q[0].t < minT){
      const x = this.q.shift();
      this.sumBuy -= x.buy;
      this.sumSell -= x.sell;
    }
  }
  push(ts, isTakerBuy, quote){
    const t = Math.floor(ts / this.bucketMs) * this.bucketMs;
    const qv = Number(quote) || 0;
    const last = this.q[this.q.length - 1];
    if (last && last.t === t){
      if (isTakerBuy) { last.buy += qv; this.sumBuy += qv; }
      else { last.sell += qv; this.sumSell += qv; }
    } else {
      const rec = { t, buy: isTakerBuy ? qv : 0, sell: isTakerBuy ? 0 : qv };
      this.q.push(rec);
      if (isTakerBuy) this.sumBuy += qv; else this.sumSell += qv;
    }
    this._prune(t);
  }
  snapshot(now){
    this._prune(now);
    const buy = this.sumBuy;
    const sell = this.sumSell;
    const vol = buy + sell;
    const delta = buy - sell;
    const imb = vol > 0 ? (delta / vol) : 0;
    return { buy, sell, vol, delta, imb };
  }
}

/* =========================================================
   CN helpers
========================================================= */
function stageCN(s){
  if (s==="SETUP") return "ğŸŸ¨ è“„å‹¢";
  if (s==="IGNITE") return "ğŸŸ§ é»ç«(çºŒåŠ›)";
  if (s==="CONFIRM") return "ğŸŸ© è§¸ç™¼";
  return "â€”";
}
function stageBadgeHtml(st){
  if (st.stage === "SETUP")  return `<span class="badge stage-setup">ğŸŸ¨ è“„å‹¢</span>`;
  if (st.stage === "IGNITE") return `<span class="badge stage-ignite">ğŸŸ§ é»ç«</span>`;
  if (st.stage === "CONFIRM")return `<span class="badge stage-confirm">ğŸŸ© è§¸ç™¼</span>`;
  return `<span class="badge muted">â€”</span>`;
}
function biasCN(b){ return b==="LONG" ? "åå¤š" : "è§€æœ›"; }
function typeCN(t){
  const m = { stop:"çªç ´å–®", limit:"é™åƒ¹", market:"å¸‚åƒ¹" };
  return m[t] || t || "-";
}
function patternCN(p){
  const m = {
    "breakout-pending":"çªç ´å‰å…†ï¼ˆå¾…è¡¨æ…‹ï¼‰",
    "continuation-pullback":"ä¸­ç¹¼å›è¸©ï¼ˆçºŒèµ°ï¼‰",
    "reversal":"åè½‰",
    "squeeze":"æ“ å£“æ”¶æ–‚",
    "chop":"ç›¤æ•´é›œè¨Š"
  };
  return m[p] || p || "-";
}

/* =========================================================
   STATE
========================================================= */
const S = new Map();          // symbol -> state
let wsMark = null;
let wsAgg = null;
let wsK1m = null;

let symbolsAll = [];
let lastHeartbeat = 0;

// candidates / pools
let candidates = [];
let watchPool = [];
let watchPoolHash = "";

// stable rank
let pinnedTop5 = [];
let pinnedUntil = 0;
let lastTopAt = 0;

// strongest lock
let lockedSym = null;
let lockedAt = 0;

// UI
let displayList = []; // [{sym,score}]

// Gemini AI store
const aiBySym = new Map();
const lastGeminiSymAt = new Map();
let geminiBlockedUntil = 0;
let geminiLastErr = "";

// Gemini limiter (RPM+RPD safety)
const GeminiLimiter = (() => {
  const KEY = "GEMINI_RPD_COUNTER_V2";
  const KEY_LAST = "GEMINI_LAST_REQ_TS_V2";

  function todayStr(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }
  function getCounter(){
    try{
      const raw = localStorage.getItem(KEY);
      if (!raw) return { day: todayStr(), used: 0 };
      const obj = JSON.parse(raw);
      if (obj.day !== todayStr()) return { day: todayStr(), used: 0 };
      return { day: obj.day, used: Number(obj.used)||0 };
    }catch(_){
      return { day: todayStr(), used: 0 };
    }
  }
  function setCounter(x){ localStorage.setItem(KEY, JSON.stringify(x)); }
  function inc(){
    const c = getCounter();
    c.used += 1;
    setCounter(c);
    return c.used;
  }
  function used(){ return getCounter().used; }

  function lastReqTs(){ return Number(localStorage.getItem(KEY_LAST) || 0); }
  function setLastReqTs(ts){ localStorage.setItem(KEY_LAST, String(ts)); }

  async function waitForSlot(){
    const now = nowMs();
    const last = lastReqTs();
    const gap = CFG.GEMINI.MIN_INTERVAL_MS;
    const wait = Math.max(0, (last + gap) - now);
    if (wait > 0) await new Promise(r=>setTimeout(r, wait));
    setLastReqTs(nowMs());
  }

  function canSpend(auto=false){
    // auto ç”¨ soft capï¼›æ‰‹å‹•å…è¨±åˆ° hard capï¼ˆä½† still limitedï¼‰
    const u = used();
    const cap = auto ? CFG.GEMINI.RPD_SOFT_CAP : CFG.GEMINI.RPD_LIMIT;
    return u < cap;
  }

  return { used, inc, canSpend, waitForSlot };
})();

function stOf(sym){
  if (S.has(sym)) return S.get(sym);

  const st = {
    sym,

    // markPrice
    lastP: null,
    lastI: null,
    premRing: new Ring(100),
    retRing: new Ring(100),
    rvHist: new Ring(240),
    premSlopeHist: new Ring(240),
    lastSampleAt: 0,
    ret5mPct: null,
    rv5m: null,
    premNow: null,
    premSlope: null,
    volZ: null,
    fundZ: null,

    // live flow windows
    flow5m: new BucketWindow(CFG.FLOW5M_MS, CFG.FLOW_BUCKET_MS),
    flow4h: new BucketWindow(CFG.FLOW4H_MS, 15000),

    flowHistVol: new Ring(CFG.FLOW_HIST_LEN),
    flowHistDelta: new Ring(CFG.FLOW_HIST_LEN),
    flowHistImb: new Ring(CFG.FLOW_HIST_LEN),
    lastFlowSampleAt: 0,

    vol5mQuote: null,
    delta5mQuote: null,
    imb5m: null,
    vol4hQuote: null,
    delta4hQuote: null,
    imb4h: null,
    vol5mZ: null,
    delta5mZ: null,

    // 1m kline
    k1m: [],
    levels: { swingHigh: null, swingLow: null, mid: null },
    patternTags: [],
    dist: { toHighPct: null, toLowPct: null },
    squeezeScore: null,
    vol1mRatio: null,
    medRange1mPct: null,

    // OI
    oi: { ts: 0, dOi5m: null, oi5mZ: null, dOi4h: null },

    // score
    score: null,

    // stage
    stage: "NONE",
    stageScore: 0,
    stageReason: "",
    stageSince: 0,
    stageUntil: 0,
    etaMin: null,
    etaMax: null,

    // ignite acceleration
    prevDeltaZ: null,
    prevDeltaZTs: 0,
  };

  S.set(sym, st);
  return st;
}

/* =========================================================
   BINANCE: Universe + markPrice WS
========================================================= */
async function loadUniverse(){
  const ex = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r=>r.json());
  symbolsAll = (ex.symbols || [])
    .filter(x => x.status === 'TRADING' && x.contractType === 'PERPETUAL' && x.quoteAsset === 'USDT')
    .map(x => x.symbol)
    .filter(s => !CFG.EXCLUDE.has(s));
}

function connectMark(){
  if (wsMark) try{ wsMark.close(); }catch(_){}
  wsMark = new WebSocket('wss://fstream.binance.com/ws/!markPrice@arr');

  wsMark.onopen = () => { lastHeartbeat = nowMs(); };

  wsMark.onmessage = (ev) => {
    lastHeartbeat = nowMs();
    const arr = JSON.parse(ev.data);

    for (const u of arr){
      const sym = u.s;
      if (!sym || CFG.EXCLUDE.has(sym)) continue;

      const st = stOf(sym);
      const p = Number(u.p);
      const i = Number(u.i);

      if (Number.isFinite(p) && st.lastP){
        st.retRing.push(Math.log(p / st.lastP));
      }
      if (Number.isFinite(p)) st.lastP = p;
      if (Number.isFinite(i)) st.lastI = i;

      if (st.lastP && st.lastI){
        st.premRing.push((st.lastP - st.lastI) / st.lastI);
      }
    }
  };

  wsMark.onclose = () => setTimeout(connectMark, 2000);
  wsMark.onerror = () => { try{ wsMark.close(); }catch(_){} };
}

function sampleMarkMetrics(){
  const now = nowMs();
  for (const st of S.values()){
    if (st.retRing.size < 20 || st.premRing.size < 20) continue;

    const rets = st.retRing.values();
    let sum = 0, sumsq = 0;
    for (const x of rets){ sum += x; sumsq += x*x; }

    st.ret5mPct = (Math.exp(sum) - 1) * 100;
    st.rv5m = Math.sqrt(sumsq) * 100;

    const prem = st.premRing.last();
    st.premNow = prem * 100;
    st.premSlope = linSlope(st.premRing.values()) * 1e4;

    if (!st.lastSampleAt || (now - st.lastSampleAt >= 60_000)){
      st.rvHist.push(st.rv5m);
      st.premSlopeHist.push(st.premSlope);
      st.lastSampleAt = now;
    }

    st.volZ = robustZ(st.rv5m, st.rvHist.values());
    st.fundZ = robustZ(st.premSlope, st.premSlopeHist.values());
  }
}

/* =========================================================
   Candidates + watchPool streams (aggTrade + kline_1m closed)
========================================================= */
function computeCandidates(){
  const arr = [];
  for (const st of S.values()){
    if (st.volZ === null) continue;

    const volPass  = Math.abs(st.volZ) >= CFG.VOL_Z_TH;
    const retPass  = (st.ret5mPct !== null) && (Math.abs(st.ret5mPct) <= CFG.MAX_RET_5M_PCT);
    const premPass = (st.premNow !== null) && (Math.abs(st.premNow) <= CFG.MAX_ABS_PREMIUM_PCT);
    if (!volPass || !retPass || !premPass) continue;

    const fundPass = (st.fundZ !== null) ? (Math.abs(st.fundZ) >= CFG.FUND_Z_TH) : false;
    const preScore = Math.abs(st.volZ) + 0.6*Math.abs(st.fundZ || 0) + (fundPass ? 0.4 : 0);

    arr.push({ sym: st.sym, preScore });
  }

  arr.sort((a,b)=>b.preScore - a.preScore);
  candidates = arr.slice(0, CFG.CANDIDATE_MAX).map(x=>x.sym);
  watchPool = arr.slice(0, CFG.WATCH_POOL_MAX).map(x=>x.sym);
}

function connectAggForWatchPool(){
  const hash = watchPool.join('|');
  if (hash === watchPoolHash) return;
  watchPoolHash = hash;

  if (wsAgg) try{ wsAgg.close(); }catch(_){}
  if (wsK1m) try{ wsK1m.close(); }catch(_){}

  if (!watchPool.length) return;

  const aggStreams = watchPool.map(s => `${s.toLowerCase()}@aggTrade`);
  wsAgg = new WebSocket(`wss://fstream.binance.com/stream?streams=${aggStreams.join('/')}`);

  wsAgg.onmessage = (ev) => {
    const msg = JSON.parse(ev.data);
    const d = msg.data;
    if (!d || d.e !== 'aggTrade') return;

    const sym = d.s;
    const st = stOf(sym);

    // m=true => buyer is maker => taker is seller; so takerBuy = !m
    const isTakerBuy = !d.m;
    const price = Number(d.p);
    const qty = Number(d.q);
    const quote = price * qty;
    const ts = Number(d.T) || nowMs();

    st.flow5m.push(ts, isTakerBuy, quote);
    st.flow4h.push(ts, isTakerBuy, quote);
  };

  wsAgg.onclose = () => setTimeout(connectAggForWatchPool, 1500);
  wsAgg.onerror = () => { try{ wsAgg.close(); }catch(_){} };

  const kStreams = watchPool.map(s => `${s.toLowerCase()}@kline_1m`);
  wsK1m = new WebSocket(`wss://fstream.binance.com/stream?streams=${kStreams.join('/')}`);

  wsK1m.onmessage = (ev) => {
    const msg = JSON.parse(ev.data);
    const data = msg.data;
    if (!data || data.e !== 'kline') return;
    const sym = data.s;
    const k = data.k;
    if (!k || !k.x) return; // only closed

    const st = stOf(sym);
    const o = Number(k.o), h = Number(k.h), l = Number(k.l), c = Number(k.c);
    const v = Number(k.v);
    st.k1m.push({ t:k.T, o,h,l,c,v });
    if (st.k1m.length > 60) st.k1m.shift();

    computeStructureAndTags(st);
  };

  wsK1m.onclose = () => setTimeout(connectAggForWatchPool, 1500);
  wsK1m.onerror = () => { try{ wsK1m.close(); }catch(_){} };
}

/* =========================================================
   Flow sampling + zscores (self compare)
========================================================= */
function sampleFlow(){
  const now = nowMs();
  for (const sym of watchPool){
    const st = stOf(sym);
    if (now - st.lastFlowSampleAt < CFG.FLOW_SAMPLE_MS) continue;

    const s5 = st.flow5m.snapshot(now);
    const s4 = st.flow4h.snapshot(now);

    st.vol5mQuote = s5.vol;
    st.delta5mQuote = s5.delta;
    st.imb5m = s5.imb;

    st.vol4hQuote = s4.vol;
    st.delta4hQuote = s4.delta;
    st.imb4h = s4.imb;

    st.flowHistVol.push(st.vol5mQuote);
    st.flowHistDelta.push(st.delta5mQuote);
    st.flowHistImb.push(st.imb5m);

    st.vol5mZ = robustZ(st.vol5mQuote, st.flowHistVol.values());
    st.delta5mZ = robustZ(st.delta5mQuote, st.flowHistDelta.values());

    st.lastFlowSampleAt = now;
  }
}

/* =========================================================
   Structure / Pattern from 1m
========================================================= */
function computeStructureAndTags(st){
  const bars = st.k1m;
  if (bars.length < 20) return;

  const seg = bars.slice(-20);
  const swingHigh = Math.max(...seg.map(b=>b.h));
  const swingLow  = Math.min(...seg.map(b=>b.l));
  st.levels.swingHigh = swingHigh;
  st.levels.swingLow = swingLow;
  st.levels.mid = (swingHigh + swingLow)/2;

  if (st.lastP){
    const p = st.lastP;
    st.dist.toHighPct = (swingHigh - p) / p * 100;
    st.dist.toLowPct  = (p - swingLow) / p * 100;
  }

  const last = seg[seg.length-1];
  const prev = seg[seg.length-2];
  const tags = [];

  const body = Math.abs(last.c - last.o);
  const rng = Math.max(1e-12, last.h - last.l);
  const bodyPct = body / rng;
  const upperWick = last.h - Math.max(last.o, last.c);
  const lowerWick = Math.min(last.o, last.c) - last.l;

  if (bodyPct < 0.2) tags.push("åå­—/çŒ¶è±«");
  if (lowerWick > 2*body && upperWick < body) tags.push("éŒ˜å­ç·šå‚¾å‘");
  if (upperWick > 2*body && lowerWick < body) tags.push("æµæ˜Ÿç·šå‚¾å‘");
  if (last.h < prev.h && last.l > prev.l) tags.push("å…§åŒ…ç·š");

  // squeeze-ish: last 10 ranges lower than median
  const ranges = seg.slice(-10).map(b => (b.h-b.l)/Math.max(1e-12,b.c));
  const medR = median(seg.map(b => (b.h-b.l)/Math.max(1e-12,b.c)));
  const smallCount = ranges.filter(x => x < 0.8*medR).length;
  if (smallCount >= 7) tags.push("æ”¶æ–‚ï¼ˆæ“ å£“ï¼‰");

  // squeeze score (0~1)
  st.squeezeScore = smallCount / 10;

  // 1m volume ratio (last vs median 20)
  const vols = seg.map(b=>b.v);
  const medV = median(vols) || 1e-12;
  st.vol1mRatio = last.v / medV;

  // median 1m range pct (ETA helper)
  const rangePct = seg.map(b => (b.h-b.l)/Math.max(1e-12,b.c)*100);
  st.medRange1mPct = median(rangePct);

  st.patternTags = tags;
}

/* =========================================================
   OI
========================================================= */
async function fetchOI(sym){
  const st = stOf(sym);
  const now = nowMs();
  if (now - st.oi.ts < CFG.OI_REFRESH_MS) return;

  const url5 = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=5m&limit=50`;
  const url4 = `https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=4h&limit=2`;

  const [d5, d4] = await Promise.all([
    fetch(url5).then(r=>r.json()).catch(()=>null),
    fetch(url4).then(r=>r.json()).catch(()=>null),
  ]);

  function sortByTs(a){ return (a||[]).slice().sort((x,y)=>(x.timestamp||0)-(y.timestamp||0)); }

  const a5 = sortByTs(d5);
  if (a5.length >= 10){
    const series = a5.map(x => Number(x.sumOpenInterestValue ?? x.sumOpenInterest));
    const diffs = [];
    for (let i=1;i<series.length;i++) diffs.push(series[i] - series[i-1]);
    const lastDiff = diffs[diffs.length-1];
    const hist = diffs.slice(0, -1);
    st.oi.dOi5m = lastDiff;
    st.oi.oi5mZ = robustZ(lastDiff, hist);
  }

  const a4 = sortByTs(d4);
  if (a4.length === 2){
    const s0 = Number(a4[0].sumOpenInterestValue ?? a4[0].sumOpenInterest);
    const s1 = Number(a4[1].sumOpenInterestValue ?? a4[1].sumOpenInterest);
    st.oi.dOi4h = (s1 - s0);
  }

  st.oi.ts = now;
}

async function refreshOI(){
  for (const sym of watchPool){
    await fetchOI(sym);
  }
}

/* =========================================================
   Stage logic + ETA
========================================================= */
function estimateETA(st){
  const dist = st.dist?.toHighPct;
  const base = st.medRange1mPct;
  if (dist === null || dist === undefined || base === null || base === undefined) return {min:null,max:null};

  const dz = clamp(st.delta5mZ || 0, 0, 4);
  const speed = Math.max(0.02, base * (1 + 0.35*dz));
  const eta = clamp(dist / speed, 1, 15);

  if (st.stage === "IGNITE") return { min: Math.max(1, Math.floor(eta*0.6)), max: Math.min(8, Math.ceil(eta*1.2)) };
  if (st.stage === "SETUP")  return { min: Math.max(2, Math.floor(eta*0.8)), max: Math.min(15, Math.ceil(eta*1.6)) };
  if (st.stage === "CONFIRM")return { min: 0, max: Math.min(3, Math.ceil(eta*0.8)) };
  return {min:null,max:null};
}

function stagePriority(stage){
  // å™´å‰å„ªå…ˆæ’åºï¼šé»ç« > è“„å‹¢ > è§¸ç™¼ > NONE
  return ({ IGNITE: 3, SETUP: 2, CONFIRM: 1, NONE: 0 }[stage] ?? 0);
}

function setStage(st, stage, score, reason){
  const now = nowMs();
  if (st.stage !== stage){
    st.stage = stage;
    st.stageSince = now;
  }
  st.stageScore = score;
  st.stageReason = reason;
  st.stageUntil = now + (CFG.STAGE.HOLD_MS[stage] || 0);

  const eta = estimateETA(st);
  st.etaMin = eta.min;
  st.etaMax = eta.max;
}

function computeStage(st){
  const now = nowMs();
  const stillHold = st.stage !== "NONE" && now < (st.stageUntil || 0);

  const toHigh = st.dist?.toHighPct;
  const ret5m = st.ret5mPct;
  const imb5m = st.imb5m;
  const d5    = st.delta5mQuote;
  const dz    = st.delta5mZ;
  const vz    = st.vol5mZ;

  // deltaZ velocity (ignite accel)
  let dzVel = 0;
  if (st.prevDeltaZ !== null && st.prevDeltaZTs){
    const dt = Math.max(1, (now - st.prevDeltaZTs) / 1000);
    dzVel = ((dz || 0) - (st.prevDeltaZ || 0)) / dt;
    dzVel = dzVel * 15; // normalize to ~ per 15s step
  }
  st.prevDeltaZ = (dz || 0);
  st.prevDeltaZTs = now;

  // CONFIRM: close above swingHigh with volume + flow
  const bars = st.k1m || [];
  const lastBar = bars.length ? bars[bars.length-1] : null;
  const high = st.levels?.swingHigh;
  const closeAbove = (lastBar && high) ? (lastBar.c > high * (1 + (CFG.STAGE.CONFIRM.CLOSE_ABOVE_HIGH_BP/10000))) : false;
  const volOk = (st.vol1mRatio || 0) >= CFG.STAGE.CONFIRM.VOL1M_RATIO_MIN;
  const flowOkC = (imb5m || 0) >= CFG.STAGE.CONFIRM.IMB5M_MIN && (d5 || 0) > 0;

  if (closeAbove && volOk && flowOkC){
    const score = 100 + (dz || 0) + 0.5*(vz || 0);
    setStage(st, "CONFIRM", score, "1mæ”¶ç·šçªç ´å£“åŠ›ä¸”æ”¾é‡ï¼Œflowåå¤š");
    return;
  }

  // IGNITE: fast deltaZ acceleration + positive flow, still under breakout
  const ign = CFG.STAGE.IGNITE;
  const ignOK =
    (dz || 0) >= ign.DELTAZ_MIN &&
    (dzVel || 0) >= ign.DELTAZ_VEL_MIN &&
    (imb5m || 0) >= ign.IMB5M_MIN &&
    (vz || 0) >= ign.VOL5MZ_MIN &&
    (toHigh !== null && toHigh !== undefined && toHigh >= ign.TO_HIGH_MIN) &&
    (ret5m === null || ret5m === undefined || ret5m <= ign.RET5M_MAX);

  if (ignOK){
    const score = 70 + 2*(dz || 0) + 0.6*(vz || 0) + 10*(imb5m || 0);
    setStage(st, "IGNITE", score, "ä¸»å‹•è²·å…¥å·®é¡åŠ é€Ÿä¸Šå‡ï¼Œé‡èƒ½é–‹å§‹ç•°å¸¸ï¼Œå°šæœªçªç ´");
    return;
  }

  // SETUP: squeeze + near resistance + not chase + buy accumulation
  const su = CFG.STAGE.SETUP;
  const squeezeOk = (st.squeezeScore || 0) >= su.SQUEEZE_MIN;
  const toHighOk = (toHigh !== null && toHigh !== undefined) && (toHigh >= su.TO_HIGH_MIN && toHigh <= su.TO_HIGH_MAX);
  const retOk = (ret5m !== null && ret5m !== undefined) ? (ret5m >= su.RET5M_MIN && ret5m <= su.RET5M_MAX) : false;
  const flowOk = (imb5m || 0) >= su.IMB5M_MIN && ((su.DELTA5M_POS && (d5 || 0) > 0) || !su.DELTA5M_POS);

  if (squeezeOk && toHighOk && retOk && flowOk){
    const score = 40 + (st.volZ || 0) + 0.5*(st.fundZ || 0) + 8*(imb5m || 0);
    setStage(st, "SETUP", score, "æ”¶æ–‚æ“ å£“ + é è¿‘å£“åŠ› + ä¸»å‹•è²·å…¥å †ç©ï¼ˆæœªå™´ï¼‰");
    return;
  }

  if (!stillHold){
    setStage(st, "NONE", 0, "");
  }
}

/* =========================================================
   Ranking + Lock (Long-only)
========================================================= */
function passLongOnly(st){
  const flowOk = (st.imb5m !== null) && (st.delta5mQuote !== null) &&
                 (st.imb5m > CFG.LONG_FLOW_IMB_MIN) &&
                 (st.delta5mQuote > 0);
  if (!flowOk) return false;
  if (CFG.LONG_REQUIRE_OI_POS && (st.oi.dOi5m || 0) < 0) return false;
  return true;
}

function updateRank(){
  const rows = [];

  for (const sym of watchPool){
    const st = stOf(sym);
    if (st.volZ === null) continue;
    if (!passLongOnly(st)) continue;
    if (st.premNow !== null && Math.abs(st.premNow) > CFG.MAX_ABS_PREMIUM_PCT) continue;
    if (st.ret5mPct !== null && st.ret5mPct > CFG.MAX_RET_5M_PCT) continue;

    const score = st.stageScore || 0;
    st.score = score;
    rows.push({ sym, score });
  }

  rows.sort((a,b)=>{
    const pa = stagePriority(stOf(a.sym).stage);
    const pb = stagePriority(stOf(b.sym).stage);
    if (pb !== pa) return pb - pa;
    return b.score - a.score;
  });

  // strongest lock
  const top1 = rows[0] || null;
  const now = nowMs();
  if (!lockedSym && top1){
    lockedSym = top1.sym; lockedAt = now;
  } else if (lockedSym && top1){
    const lockedRow = rows.find(x=>x.sym === lockedSym);
    if (!lockedRow){
      lockedSym = top1.sym; lockedAt = now;
    } else if (top1.sym !== lockedSym){
      const holdOk = (now - lockedAt) >= CFG.LOCK_MIN_HOLD_MS;
      const ratioOk = top1.score > lockedRow.score * CFG.LOCK_SWITCH_RATIO;
      const absOk   = top1.score > lockedRow.score + CFG.LOCK_SWITCH_ABS;
      if (holdOk && (ratioOk || absOk)){
        lockedSym = top1.sym; lockedAt = now;
      }
    }
  }

  // desired top5: locked first then highest
  const desired = [];
  if (lockedSym){
    const lr = rows.find(x=>x.sym === lockedSym);
    if (lr) desired.push(lr.sym);
  }
  for (const r of rows){
    if (desired.length >= 5) break;
    if (!desired.includes(r.sym)) desired.push(r.sym);
  }

  // stable pin
  const frozen = now < pinnedUntil;
  if (!pinnedTop5.length || !frozen){
    pinnedTop5 = desired.slice(0,5);
    pinnedUntil = now + CFG.RANK_FREEZE_MS;
  } else {
    const current = pinnedTop5.slice(0,5);
    const scoresMap = new Map(rows.map(x=>[x.sym,x.score]));
    const weakestSym = current.slice().sort((a,b)=>(scoresMap.get(a)||-999)-(scoresMap.get(b)||-999))[0];
    const weakestScore = scoresMap.get(weakestSym) ?? -999;

    if (lockedSym && !current.includes(lockedSym)) current[0] = lockedSym;

    for (const cand of desired){
      if (current.includes(cand)) continue;
      const candScore = scoresMap.get(cand) ?? -999;
      const ratioOk = candScore > weakestScore * CFG.RANK_REPLACE_RATIO;
      const absOk = candScore > weakestScore + CFG.RANK_REPLACE_ABS;
      if (ratioOk || absOk){
        const idx = current.indexOf(weakestSym);
        if (idx !== -1) current[idx] = cand;
        break;
      }
    }
    pinnedTop5 = current;
  }

  const scoreMap = new Map(rows.map(x=>[x.sym,x.score]));
  displayList = pinnedTop5.map(sym => ({ sym, score: scoreMap.get(sym) ?? 0 })).filter(x=>x.sym);

  lastTopAt = now;
  document.getElementById('lastUpdate').innerText = new Date(lastTopAt).toLocaleTimeString();
}

/* =========================================================
   Gemini: key + parsing + prompt + normalize + display
========================================================= */
function getGeminiKey(){
  const k = document.getElementById('geminiKey').value.trim();
  return k || (localStorage.getItem('GEMINI_API_KEY') || "");
}
function saveGeminiKey(){
  const k = document.getElementById('geminiKey').value.trim();
  if (!k) return alert("Key ç©ºçš„");
  localStorage.setItem('GEMINI_API_KEY', k);
  alert("å·²å­˜åˆ° localStorageï¼ˆåªåœ¨é€™å°ç€è¦½å™¨ï¼‰");
}
function clearGeminiKey(){
  localStorage.removeItem('GEMINI_API_KEY');
  document.getElementById('geminiKey').value = "";
  alert("å·²æ¸…é™¤");
}
function safeParseJson(maybe){
  let s = String(maybe || "").trim();
  s = s.replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
  const first = s.indexOf("{");
  const last  = s.lastIndexOf("}");
  if (first !== -1 && last !== -1 && last > first) s = s.slice(first, last + 1);
  return JSON.parse(s);
}

function normalizeAi(ai, sym){
  const st = stOf(sym);
  const p = st.lastP || 0;

  const out = {
    symbol: sym,
    stage_now: ["SETUP","IGNITE","CONFIRM","NONE"].includes(ai?.stage_now) ? ai.stage_now : st.stage,
    bias: ai?.bias === "LONG" ? "LONG" : "NEUTRAL",
    confidence: Number.isFinite(Number(ai?.confidence)) ? Number(ai.confidence) : 0,
    pattern: ai?.pattern || "chop",

    eta_minutes: {
      min: Number.isFinite(Number(ai?.eta_minutes?.min)) ? Number(ai.eta_minutes.min) : (st.etaMin ?? 0),
      max: Number.isFinite(Number(ai?.eta_minutes?.max)) ? Number(ai.eta_minutes.max) : (st.etaMax ?? 0),
      logic: String(ai?.eta_minutes?.logic || "æœªæä¾›")
    },

    action_now: String(ai?.action_now || "è§€å¯Ÿ/ç­‰å¾…"),

    entry: {
      type: ["stop","limit","market"].includes(ai?.entry?.type) ? ai.entry.type : "market",
      price: Number.isFinite(Number(ai?.entry?.price)) ? Number(ai.entry.price) : p,
      condition: String(ai?.entry?.condition || "æœªæä¾›"),
      logic: String(ai?.entry?.logic || "æœªæä¾›")
    },

    stop: {
      price: Number.isFinite(Number(ai?.stop?.price)) ? Number(ai.stop.price) : p,
      logic: String(ai?.stop?.logic || "æœªæä¾›")
    },

    takeProfit: Array.isArray(ai?.takeProfit) ? ai.takeProfit.map(x=>({
      price: Number.isFinite(Number(x?.price)) ? Number(x.price) : null,
      ratio: Number.isFinite(Number(x?.ratio)) ? Number(x.ratio) : null,
      logic: String(x?.logic || "")
    })).filter(x=>x.price!==null) : [],

    invalidation: String(ai?.invalidation || "æœªæä¾›"),
    risk_note: String(ai?.risk_note || "æœªæä¾›"),

    plan_by_stage: {
      SETUP: String(ai?.plan_by_stage?.SETUP || "æœªæä¾›"),
      IGNITE: String(ai?.plan_by_stage?.IGNITE || "æœªæä¾›"),
      CONFIRM: String(ai?.plan_by_stage?.CONFIRM || "æœªæä¾›")
    },

    notes: Array.isArray(ai?.notes) ? ai.notes.map(x=>String(x)) : []
  };

  return out;
}

function buildGeminiPrompt(sym){
  const st = stOf(sym);

  const summary = {
    symbol: sym,
    stage_now: st.stage,
    stage_reason: st.stageReason,
    eta_local: { min: st.etaMin, max: st.etaMax },

    // anomaly
    vol_z: st.volZ,
    fund_z: st.fundZ,
    ret_5m_pct: st.ret5mPct,
    premium_pct: st.premNow,

    // flow
    taker_5m: { vol_quote: st.vol5mQuote, delta_quote: st.delta5mQuote, imb: st.imb5m, delta_z: st.delta5mZ, vol_z: st.vol5mZ },
    taker_4h: { vol_quote: st.vol4hQuote, delta_quote: st.delta4hQuote, imb: st.imb4h },

    // OI
    oi: { d_5m: st.oi.dOi5m, z_5m: st.oi.oi5mZ, d_4h: st.oi.dOi4h },

    // structure
    levels_1m_20: st.levels,
    dist_to_swingHigh_pct: st.dist.toHighPct,
    dist_to_swingLow_pct: st.dist.toLowPct,
    squeeze_score: st.squeezeScore,
    vol1m_ratio: st.vol1mRatio,
    tags_1m: st.patternTags,

    last_price: st.lastP
  };

  return `
ä½ æ˜¯ã€Œåˆç´„çŸ­ç·šï¼ˆ5~10åˆ†é˜ï¼‰åšå¤šç­–ç•¥å¯©æ ¸å“¡ã€ã€‚
åªèƒ½åšã€åšå¤šã€‘ï¼›è‹¥ä¸é©åˆåšå¤šï¼Œbias=NEUTRALã€‚
è«‹æ ¹æ“šæˆ‘æä¾›çš„æ‘˜è¦ JSONï¼Œè¼¸å‡ºã€åš´æ ¼ JSONã€‘ï¼ˆä¸å¯å«ä»»ä½•å¤šé¤˜æ–‡å­—ï¼‰ã€‚
ä½ å¿…é ˆæä¾›ï¼šé è¨ˆå¹¾åˆ†é˜å…§è¡¨æ…‹(å€é–“)ã€ç¾åœ¨æ‡‰åšä»€éº¼(action_now)ã€é€²å ´æ–¹å¼èˆ‡æ¢ä»¶ã€åœæã€åˆ†æ‰¹æ­¢ç›ˆã€å¤±æ•ˆæ¢ä»¶ã€é¢¨éšªæç¤ºï¼Œ
ä»¥åŠé‡å°ä¸‰ç¨®ç‹€æ…‹ï¼ˆSETUP/IGNITE/CONFIRMï¼‰å„è‡ªçš„æ“ä½œè¨ˆç•«(plan_by_stage)ã€‚

ã€æ‘˜è¦ JSONã€‘
${JSON.stringify(summary)}

ã€åªè¼¸å‡º JSONã€‘schema:
{
  "symbol":"string",
  "stage_now":"SETUP|IGNITE|CONFIRM|NONE",
  "bias":"LONG|NEUTRAL",
  "confidence":number,
  "pattern":"breakout-pending|continuation-pullback|reversal|squeeze|chop",

  "eta_minutes":{"min":number,"max":number,"logic":"string"},
  "action_now":"string",

  "entry":{"type":"stop|limit|market","price":number,"condition":"string","logic":"string"},
  "stop":{"price":number,"logic":"string"},
  "takeProfit":[{"price":number,"ratio":number,"logic":"string"}],

  "invalidation":"string",
  "risk_note":"string",

  "plan_by_stage":{"SETUP":"string","IGNITE":"string","CONFIRM":"string"},
  "notes":["string"]
}
  `.trim();
}

async function callGemini(sym, isAuto){
  const key = getGeminiKey();
  const now = nowMs();

  if (!key) throw new Error("ç¼ºå°‘ Gemini keyï¼ˆå…ˆè²¼ä¸Šå† Saveï¼‰");
  if (now < geminiBlockedUntil) throw new Error(`Gemini æš«åœä¸­ï¼ˆ429 backoffï¼‰ï¼Œå‰©é¤˜ ${Math.ceil((geminiBlockedUntil-now)/1000)} ç§’`);
  if (!GeminiLimiter.canSpend(isAuto)) throw new Error(`ä»Šæ—¥ AI é¡åº¦å·²åˆ°ä¸Šé™ï¼ˆautoä¿ç•™/æˆ–RPDï¼‰`);

  // RPM gating
  await GeminiLimiter.waitForSlot();

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${CFG.GEMINI.MODEL}:generateContent`;
  const body = {
    contents: [{ role: "user", parts: [{ text: buildGeminiPrompt(sym) }] }],
    generationConfig: {
      temperature: CFG.GEMINI.TEMP,
      max_output_tokens: CFG.GEMINI.MAX_OUTPUT_TOKENS,
      response_mime_type: "application/json"
    }
  };

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type":"application/json", "x-goog-api-key": key },
    body: JSON.stringify(body)
  });

  const raw = await res.text();
  if (!res.ok){
    geminiLastErr = `HTTP ${res.status}: ${raw.slice(0,220)}`;
    if (res.status === 429){
      geminiBlockedUntil = now + CFG.GEMINI.BACKOFF_429_MS;
    }
    throw new Error(geminiLastErr);
  }

  GeminiLimiter.inc();

  const json = JSON.parse(raw);
  const text = json?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
  const parsed = safeParseJson(text);
  return normalizeAi(parsed, sym);
}

function formatAiPanel(ai){
  const bias = biasCN(ai.bias);
  const conf = ai.confidence ?? 0;
  const patt = patternCN(ai.pattern);
  const eta = `${ai.eta_minutes.min}~${ai.eta_minutes.max} åˆ†`;
  const entry = `${typeCN(ai.entry.type)} @ ${ai.entry.price}`;
  const tp = (ai.takeProfit||[]).length
    ? ai.takeProfit.map(x=>`${x.price}${x.ratio!=null?`(${x.ratio}%)`:''}`).join(" / ")
    : "ï¼ˆæœªæä¾›ï¼‰";

  const notes = (ai.notes||[]).slice(0,4);
  const notesHtml = notes.length ? notes.map(x=>`â€¢ ${escapeHtml(x)}`).join("<br/>") : "ï¼ˆç„¡ï¼‰";

  return `
    <div class="text-[12px] text-white font-bold">AI åˆ¤è®€ï¼ˆä¸­æ–‡ï¼‰</div>
    <div class="text-[11px] mono mt-2 leading-relaxed">
      <div>ç›®å‰ç‹€æ…‹ï¼š<span class="text-white font-bold">${escapeHtml(stageCN(ai.stage_now))}</span></div>
      <div>æ–¹å‘ï¼š<span class="${ai.bias==="LONG"?"ok font-bold":"muted"}">${bias}</span>ï½œä¿¡å¿ƒï¼š<span class="text-white font-bold">${conf}</span>/100</div>
      <div>å‹æ…‹ï¼š<span class="text-white">${escapeHtml(patt)}</span></div>
      <div>é è¨ˆè¡¨æ…‹ï¼š<span class="text-white font-bold">${escapeHtml(eta)}</span>ï½œ<span class="muted">${escapeHtml(ai.eta_minutes.logic||"")}</span></div>

      <div class="mt-2">ç¾åœ¨æ€éº¼åšï¼š<span class="text-white font-bold">${escapeHtml(ai.action_now||"")}</span></div>

      <div class="mt-2">é€²å ´ï¼š<span class="text-white">${escapeHtml(entry)}</span></div>
      <div class="muted">æ¢ä»¶ï¼š${escapeHtml(ai.entry.condition||"")}</div>
      <div class="muted">ç†ç”±ï¼š${escapeHtml(ai.entry.logic||"")}</div>

      <div class="mt-2">åœæï¼š<span class="text-white">${escapeHtml(String(ai.stop.price))}</span></div>
      <div class="muted">ç†ç”±ï¼š${escapeHtml(ai.stop.logic||"")}</div>

      <div class="mt-2">æ­¢ç›ˆ(åˆ†æ‰¹)ï¼š<span class="text-white">${escapeHtml(tp)}</span></div>

      <div class="mt-2">å¤±æ•ˆæ¢ä»¶ï¼š<span class="text-white">${escapeHtml(ai.invalidation||"")}</span></div>
      <div class="mt-2">é¢¨éšªæç¤ºï¼š<span class="warn font-bold">${escapeHtml(ai.risk_note||"")}</span></div>

      <div class="mt-3 text-white font-bold">ä¸‰ç¨®ç‹€æ…‹æ“ä½œè¨ˆç•«</div>
      <div class="mt-1"><span class="badge stage-setup">ğŸŸ¨ SETUP</span> <span class="text-white">${escapeHtml(ai.plan_by_stage.SETUP||"")}</span></div>
      <div class="mt-1"><span class="badge stage-ignite">ğŸŸ§ IGNITE</span> <span class="text-white">${escapeHtml(ai.plan_by_stage.IGNITE||"")}</span></div>
      <div class="mt-1"><span class="badge stage-confirm">ğŸŸ© CONFIRM</span> <span class="text-white">${escapeHtml(ai.plan_by_stage.CONFIRM||"")}</span></div>

      <div class="muted mt-3">å‚™è¨»ï¼š<br/>${notesHtml}</div>
    </div>
  `;
}

/* =========================================================
   AI actions (manual + auto "ignite only")
========================================================= */
async function analyzeOne(sym, isAuto=false){
  const now = nowMs();
  const lastTs = lastGeminiSymAt.get(sym) || 0;
  if (now - lastTs < CFG.GEMINI.SYMBOL_COOLDOWN_MS) return;

  const st = stOf(sym);

  // show pending
  aiBySym.set(sym, normalizeAi({
    symbol:sym,
    stage_now: st.stage,
    bias:"NEUTRAL",
    confidence:0,
    pattern:"chop",
    eta_minutes:{min: st.etaMin ?? 0, max: st.etaMax ?? 0, logic:"åˆ†æä¸­â€¦"},
    action_now:"åˆ†æä¸­â€¦",
    entry:{type:"market",price:st.lastP||0,condition:"-",logic:"-"},
    stop:{price:st.lastP||0,logic:"-"},
    takeProfit:[],
    invalidation:"-",
    risk_note:"-",
    plan_by_stage:{SETUP:"åˆ†æä¸­â€¦",IGNITE:"åˆ†æä¸­â€¦",CONFIRM:"åˆ†æä¸­â€¦"},
    notes:["åˆ†æä¸­â€¦"]
  }, sym));
  render();

  try{
    const res = await callGemini(sym, isAuto);
    aiBySym.set(sym, res);
    lastGeminiSymAt.set(sym, nowMs());
    render();
  }catch(e){
    const msg = String(e.message || e);
    const is429 = msg.includes("429");
    const note = is429 ? "Gemini 429ï¼šé…é¡/é€Ÿç‡é™åˆ¶ï¼ˆè«‹æª¢æŸ¥ RPD/RPM æˆ–èª²é‡‘ï¼‰" : "Gemini å‘¼å«å¤±æ•—";
    aiBySym.set(sym, normalizeAi({
      symbol:sym,
      stage_now: st.stage,
      bias:"NEUTRAL",
      confidence:0,
      pattern:"chop",
      eta_minutes:{min: st.etaMin ?? 0, max: st.etaMax ?? 0, logic: note},
      action_now:"æš«åœ AIï¼Œå…ˆçœ‹æœ¬åœ°ç‡ˆè™Ÿ",
      entry:{type:"market",price:st.lastP||0,condition:"-",logic:note},
      stop:{price:st.lastP||0,logic:"-"},
      takeProfit:[],
      invalidation:"-",
      risk_note:"-",
      plan_by_stage:{SETUP:"å…ˆçœ‹ğŸŸ¨/ğŸŸ§",IGNITE:"çºŒåŠ›æˆç«‹å†è©¦ä¸€æ¬¡ AI",CONFIRM:"æœ¬åœ°è§¸ç™¼å·²è¶³å¤ "},
      notes:[msg.slice(0,220)]
    }, sym));
    lastGeminiSymAt.set(sym, nowMs());
    render();
  }
}

async function analyzeTopManual(){
  // æ‰‹å‹•ï¼šTop 2ï¼ˆä½ è¦å¯æ”¹ï¼‰
  const pick = displayList.slice(0,2).map(x=>x.sym);
  for (const sym of pick){
    await analyzeOne(sym, false);
  }
}

async function autoAiTick(){
  if (!CFG.GEMINI.AUTO_ENABLED) return;
  const key = getGeminiKey();
  if (!key) return;
  if (nowMs() < geminiBlockedUntil) return;

  // åªå•æœ€å¼·é–å®šï¼ˆå»ºè­°ï¼Œé¿å… RPD çˆ†ï¼‰
  const target = CFG.GEMINI.AUTO_ONLY_LOCKED ? lockedSym : (displayList[0]?.sym || null);
  if (!target) return;

  const st = stOf(target);

  // âœ… çºŒåŠ›æ‰è¨ªå• AIï¼šå¿…é ˆæ˜¯ IGNITE ä¸”æŒçºŒ >= AUTO_TRIGGER_HOLD_MS
  if (st.stage !== CFG.GEMINI.AUTO_TRIGGER_STAGE) return;
  if (!st.stageSince) return;
  if (nowMs() - st.stageSince < CFG.GEMINI.AUTO_TRIGGER_HOLD_MS) return;

  // é¿å…åŒå¹£ä¸€ç›´å•
  const lastTs = lastGeminiSymAt.get(target) || 0;
  if (nowMs() - lastTs < CFG.GEMINI.SYMBOL_COOLDOWN_MS) return;

  // auto ç”¨ soft cap
  if (!GeminiLimiter.canSpend(true)) return;

  await analyzeOne(target, true);
}

/* =========================================================
   UI render
========================================================= */
function render(){
  const alive = (nowMs() - lastHeartbeat) < 5000;
  document.getElementById('hb').className = `inline-block w-2 h-2 rounded-full ${alive ? 'bg-emerald-500' : 'bg-zinc-600'}`;

  const now = nowMs();
  const freezeLeft = Math.max(0, pinnedUntil - now);
  document.getElementById('freeze').innerText = pinnedTop5.length ? `${Math.ceil(freezeLeft/1000)}s` : "-";
  document.getElementById('lockUI').innerText = lockedSym ? `${lockedSym} (${Math.floor((now-lockedAt)/1000)}s)` : "-";

  const zReady = [...S.values()].filter(x => x.volZ !== null).length;
  const rpdUsed = GeminiLimiter.used();
  const blockInfo = (now < geminiBlockedUntil) ? `GEMINI_BLOCK=${Math.ceil((geminiBlockedUntil-now)/1000)}s` : "GEMINI_OK";

  document.getElementById('status').innerText =
    `universe=${symbolsAll.length} | states=${S.size} | zReady=${zReady} | candidates=${candidates.length} | watch=${watchPool.length} | RPD_used=${rpdUsed}/${CFG.GEMINI.RPD_LIMIT} | ${blockInfo} | err=${geminiLastErr?geminiLastErr.slice(0,80):"-"}`;

  const wrap = document.getElementById('top5');
  wrap.innerHTML = "";

  for (let i=0; i<displayList.length; i++){
    const row = displayList[i];
    const sym = row.sym;
    const st = stOf(sym);

    const isLocked = sym === lockedSym;
    const isTop1 = i === 0;

    const badges = [];
    if (isLocked) badges.push(`<span class="badge ok">ğŸ¯ æœ€å¼·é–å®š</span>`);
    if (isTop1) badges.push(`<span class="badge" style="color:#60a5fa;border-color:#60a5fa;">ğŸ† ç¬¬1å</span>`);
    badges.push(stageBadgeHtml(st));

    if (st.etaMin !== null && st.etaMax !== null){
      badges.push(`<span class="badge text-zinc-200">ETA ${st.etaMin}~${st.etaMax}m</span>`);
    }
    if (st.stageReason){
      badges.push(`<span class="badge muted">${escapeHtml(st.stageReason)}</span>`);
    }
    badges.push(`<span class="badge muted">score ${fmt(row.score,2)}</span>`);

    const ai = aiBySym.get(sym);
    const aiHtml = ai ? formatAiPanel(ai) : `<div class="text-[11px] muted">å°šæœªåˆ†æï¼šåªæœ‰ã€ŒğŸŸ§é»ç«çºŒåŠ›ã€æ‰æœƒè‡ªå‹•å• AIï¼›ä½ ä¹Ÿå¯æŒ‰å³ä¸Š Gemini æ‰‹å‹•å•</div>`;

    const card = document.createElement('div');
    card.className = `p-3 rounded-lg border border-zinc-800 bg-black/20 ${isLocked ? 'locked' : ''} ${isTop1 ? 'top1' : ''}`;

    card.innerHTML = `
      <div class="flex flex-col lg:flex-row gap-3">
        <!-- LEFT -->
        <div class="flex-1">
          <div class="flex items-start justify-between gap-3">
            <div>
              <div class="text-white font-black text-lg">${sym}</div>
              <div class="text-[11px] muted mono mt-1">${badges.join(" ")}</div>
              <div class="text-[11px] muted mono mt-1">å‹æ…‹æ¨™ç±¤ï¼š${(st.patternTags||[]).join(" / ") || "-"}</div>
            </div>
            <div class="flex items-center gap-2">
              <button class="btn btn-dark">Gemini</button>
            </div>
          </div>

          <div class="grid grid-cols-2 md:grid-cols-3 gap-2 mt-3 text-[11px] mono">
            <div class="pill rounded px-2 py-1">æ³¢å‹•ç•°å¸¸Zï¼š<span class="text-white">${fmt(st.volZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">è³‡è²»æ–œç‡Zï¼š<span class="text-white">${fmt(st.fundZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">5åˆ†é˜æ¼²è·Œï¼š<span class="text-white">${pct(st.ret5mPct,2)}</span></div>

            <div class="pill rounded px-2 py-1">æº¢åƒ¹(æ¨™è¨˜-æŒ‡æ•¸)ï¼š<span class="text-white">${pct(st.premNow,3)}</span></div>
            <div class="pill rounded px-2 py-1">æ”¶æ–‚åˆ†æ•¸(æ“ å£“)ï¼š<span class="text-white">${fmt(st.squeezeScore,2)}</span></div>
            <div class="pill rounded px-2 py-1">1mé‡èƒ½å€ç‡ï¼š<span class="text-white">${fmt(st.vol1mRatio,2)}</span></div>

            <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥æ¯”ä¾‹(5m)ï¼š<span class="text-white">${fmt(st.imb5m,3)}</span></div>
            <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥å·®é¡(5m)ï¼š<span class="text-white">${fmtInt(st.delta5mQuote)}</span></div>
            <div class="pill rounded px-2 py-1">å·®é¡ç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.delta5mZ,2)}</span></div>

            <div class="pill rounded px-2 py-1">æˆäº¤é‡ç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.vol5mZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">OIç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.oi.oi5mZ,2)}</span></div>
            <div class="pill rounded px-2 py-1">OIè®ŠåŒ–(4h)ï¼š<span class="text-white">${fmt(st.oi.dOi4h,2)}</span></div>

            <div class="pill rounded px-2 py-1">è·é«˜/ä½é»(%)ï¼š<span class="text-white">${fmt(st.dist.toHighPct,2)}/${fmt(st.dist.toLowPct,2)}</span></div>
            <div class="pill rounded px-2 py-1">é—œéµä½(1m-20)ï¼š<span class="text-white">${fmt(st.levels.swingLow,6)} ~ ${fmt(st.levels.swingHigh,6)}</span></div>
            <div class="pill rounded px-2 py-1">ä¸­ä½(mid)ï¼š<span class="text-white">${fmt(st.levels.mid,6)}</span></div>
          </div>
        </div>

        <!-- RIGHT -->
        <div class="w-full lg:w-[460px] shrink-0">
          <div class="p-3 rounded-lg border border-zinc-800 bg-black/30 h-full">
            ${aiHtml}
          </div>
        </div>
      </div>
    `;

    // per-card Gemini button (manual)
    card.querySelector('button').onclick = async () => { await analyzeOne(sym, false); };

    wrap.appendChild(card);
  }
}

/* =========================================================
   PIPELINE
========================================================= */
async function pipelineTick(){
  computeCandidates();
  connectAggForWatchPool();
  sampleFlow();
  await refreshOI();

  // stage update first
  for (const sym of watchPool){
    const st = stOf(sym);
    computeStage(st);
  }

  updateRank();
}

/* =========================================================
   UI binds + boot
========================================================= */
document.getElementById('saveKeyBtn').onclick = saveGeminiKey;
document.getElementById('clearKeyBtn').onclick = clearGeminiKey;
document.getElementById('resetBtn').onclick = () => location.reload();
document.getElementById('analyzeBtn').onclick = analyzeTopManual;

document.getElementById('autoAiBtn').onclick = () => {
  CFG.GEMINI.AUTO_ENABLED = !CFG.GEMINI.AUTO_ENABLED;
  document.getElementById('autoAiBtn').innerText = `Auto AI: ${CFG.GEMINI.AUTO_ENABLED ? "ON" : "OFF"}`;
  document.getElementById('autoAiBtn').className = CFG.GEMINI.AUTO_ENABLED ? "btn btn-green" : "btn btn-dark";
};

document.getElementById('testGeminiBtn').onclick = async () => {
  try{
    const key = getGeminiKey();
    if(!key) return alert("å…ˆè²¼ä¸Š Gemini key å†æ¸¬è©¦ï¼ˆå¯æŒ‰ Saveï¼‰");
    if (nowMs() < geminiBlockedUntil) return alert("ç›®å‰è¢« 429 backoff æš«åœï¼Œç¨å¾Œå†è©¦");
    if (!GeminiLimiter.canSpend(false)) return alert("ä»Šæ—¥ RPD é¡åº¦ç”¨å®Œï¼ˆæˆ– auto ä¿ç•™ï¼‰");

    await GeminiLimiter.waitForSlot();

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${CFG.GEMINI.MODEL}:generateContent`;
    const res = await fetch(url,{
      method:"POST",
      headers:{ "Content-Type":"application/json", "x-goog-api-key": key },
      body: JSON.stringify({
        contents:[{role:"user",parts:[{text:`åªå›å‚³JSONï¼š{"ok":true,"ts":${nowMs()}}`}]}],
        generationConfig:{ temperature:0.1, max_output_tokens: 80, response_mime_type:"application/json" }
      })
    });
    const t = await res.text();
    console.log("Gemini test raw:", t);

    if(!res.ok){
      if (res.status === 429) geminiBlockedUntil = nowMs() + CFG.GEMINI.BACKOFF_429_MS;
      return alert(`Gemini FAIL: HTTP ${res.status}ï¼ˆçœ‹ Consoleï¼‰`);
    }
    GeminiLimiter.inc();
    alert("Gemini OK âœ…ï¼ˆçœ‹ Console å¯ç¢ºèªå›æ‡‰ï¼‰");
  }catch(e){
    alert("Gemini error: " + e.message);
  }
};

(function initKey(){
  const k = localStorage.getItem('GEMINI_API_KEY') || "";
  if (k) document.getElementById('geminiKey').value = k;
})();

(async function main(){
  try{
    await loadUniverse();
  }catch(e){
    document.getElementById('status').innerText = `exchangeInfo å¤±æ•—: ${e.message}`;
    return;
  }

  connectMark();

  setInterval(sampleMarkMetrics, 1000);
  setInterval(render, 1000);
  setInterval(() => { pipelineTick().catch(()=>{}); }, 10_000);

  // auto AI poll
  setInterval(() => { autoAiTick().catch(()=>{}); }, CFG.GEMINI.AUTO_POLL_MS);

})();
</script>

</body>
</html>
