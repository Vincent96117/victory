<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7 â€” Long-only Anomaly Scanner (Top5 â†’ Gemini)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    body { background:#050505; color:#d4d4d8; font-family:'JetBrains Mono', monospace; }
    .card { background:#0f0f11; border:1px solid #1f1f23; border-radius:14px; }
    .pill { border:1px solid #2a2a31; background:#0b0b0d; border-radius:999px; padding:2px 8px; font-size:11px; color:#a1a1aa; }
    .pill-strong { border-color:#22c55e; color:#22c55e; }
    .pill-warn { border-color:#f59e0b; color:#f59e0b; }
    .pill-danger { border-color:#ef4444; color:#ef4444; }
    .mono { font-family:'JetBrains Mono', monospace; }
    .muted { color:#71717a; }
    .grid-2 { display:grid; grid-template-columns: 1.1fr 0.9fr; gap:12px; }
    .k { color:#a1a1aa; font-size:12px; }
    .v { color:#e4e4e7; font-size:12px; font-weight:700; }
    .box { border:1px solid #22222a; background:#0b0b0d; border-radius:10px; padding:10px; }
    .led { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .led-off { background:#3f3f46; box-shadow:none; }
    .led-on { background:#22c55e; box-shadow:0 0 12px rgba(34,197,94,.65); }
    .led-warn { background:#f59e0b; box-shadow:0 0 12px rgba(245,158,11,.55); }
    .led-bad { background:#ef4444; box-shadow:0 0 12px rgba(239,68,68,.45); }
    .rank1 { outline:2px solid rgba(34,197,94,.55); }
    .btn { border:1px solid #2a2a31; background:#0b0b0d; color:#e4e4e7; padding:8px 10px; border-radius:10px; font-size:12px; font-weight:800; }
    .btn:hover { background:#111114; }
    .btn-blue { border-color:#2563eb; background:rgba(37,99,235,.15); color:#93c5fd; }
    .btn-green { border-color:#10b981; background:rgba(16,185,129,.15); color:#6ee7b7; }
    .btn-amber { border-color:#f59e0b; background:rgba(245,158,11,.12); color:#fde68a; }
    .btn-red { border-color:#ef4444; background:rgba(239,68,68,.12); color:#fecaca; }
    .small { font-size:11px; }
    .nowrap { white-space:nowrap; }
    .ai-title { font-size:12px; font-weight:900; color:#fff; }
    .ai-line { font-size:12px; line-height:1.35; }
    .ai-b { color:#e4e4e7; font-weight:900; }
    .ai-w { color:#f59e0b; font-weight:900; }
    .ai-g { color:#22c55e; font-weight:900; }
    .ai-r { color:#ef4444; font-weight:900; }
  </style>
</head>

<body class="p-4">
  <!-- HEADER -->
  <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
    <div class="flex items-center gap-3">
      <span id="led-scan" class="led led-off"></span>
      <div>
        <div class="text-xl font-black text-white italic">TRIDENT <span class="text-emerald-400">V7</span></div>
        <div class="text-[10px] muted font-bold uppercase tracking-widest">Long-only â€¢ Anomaly-first â€¢ Top5 â†’ Gemini (Top3 Ignite/Confirm)</div>
      </div>
    </div>

    <div class="flex flex-wrap items-center gap-2">
      <div class="flex items-center gap-2 box py-2 px-3">
        <span class="text-[11px] muted font-bold">Gemini Key</span>
        <input id="keyInput" class="mono text-[12px] bg-black/30 border border-zinc-700 rounded px-2 py-1 w-64 text-white outline-none"
               placeholder="è²¼ä¸Šä½ çš„ Gemini API Keyï¼ˆä¸æœƒä¸Šå‚³ï¼Œåªå­˜æœ¬æ©Ÿï¼‰" />
        <button id="btnSaveKey" class="btn btn-green">Save</button>
        <button id="btnClearKey" class="btn btn-red">Clear</button>
      </div>

      <button id="btnTestGemini" class="btn btn-amber">Test Gemini</button>
      <button id="btnAnalyzeTop" class="btn btn-blue">Analyze Top (Gemini)</button>

      <div class="box py-2 px-3 flex items-center gap-3">
        <div class="flex items-center gap-2">
          <span class="text-[11px] muted font-bold">Auto</span>
          <button id="btnAuto" class="btn">OFF</button>
        </div>
        <div class="text-[11px] muted">
          <span id="statusLine">status: -</span>
        </div>
      </div>
    </div>
  </div>

  <!-- META BAR -->
  <div class="mt-3 flex flex-wrap gap-2 items-center">
    <span class="pill">æ¨¡å‹: <span id="modelName" class="ai-b">gemini-2.5-flash</span></span>
    <span class="pill">max_out: <span id="maxOut" class="ai-b">420</span></span>
    <span class="pill">TopK: <span id="topK" class="ai-b">3</span> (Ignite/Confirm only)</span>
    <span class="pill">æ›´æ–°: <span id="lastUpdate" class="ai-b">-</span></span>
    <span class="pill">Universe: <span id="uCount" class="ai-b">-</span></span>
    <span class="pill">æ’é™¤å¸‚å€¼Top25: <span id="mcapStatus" class="ai-b">è¼‰å…¥ä¸­â€¦</span></span>
    <span class="pill">Gemini: <span id="geminiStatus" class="ai-b">-</span></span>
    <span class="pill">RateLimit: <span id="geminiRL" class="ai-b">-</span></span>
  </div>

  <!-- MAIN -->
  <div class="mt-4">
    <div class="text-white font-black text-lg mb-2">Top 5 å€™é¸ï¼ˆæœ€å¼·é–å®šç½®é ‚ï¼‰</div>
    <div id="cards" class="flex flex-col gap-3"></div>
  </div>

<script>
/* ============================================================
   TRIDENT V7 (Long-only) â€” GitHub Pages friendly
   - Binance Futures public API (no trading)
   - CoinGecko market-cap top25 exclusion
   - Top5 anomaly-first ranking (smoothing + strongest lock)
   - Gemini structured output (responseSchema) + robust parsing
============================================================ */

const CFG = {
  // Binance
  BINANCE_FAPI: "https://fapi.binance.com",
  EXCLUDE_SYMBOLS: new Set(["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT"]),

  // Universe
  UNIVERSE_TOP_BY_QV: 80,         // scan top 80 by 24h quoteVolume
  UNIVERSE_MIN_QV: 5_000_000,     // filter small contracts
  REFRESH_UNIVERSE_EVERY_MS: 10 * 60 * 1000,

  // Klines
  KLINE_INTERVAL: "1m",
  KLINE_LIMIT: 240,              // 4 hours
  SCAN_BATCH_SIZE: 8,
  SCAN_TICK_MS: 6000,

  // Stage thresholds (C-mode: pre-break)
  VOLATILITY_Z_MIN: 1.5,          // anomaly-first gate
  VOLZ5_MIN: 1.6,
  ACTIVE_RATIO5_MIN: 0.50,

  PREBREAK_TO_HIGH_MAX_PCT: 0.18, // within 0.18% of 20bar high
  PREBREAK_VOL1M_RATIO_MIN: 1.6,
  PREBREAK_RET5_RANGE: [-0.05, 0.60], // anti-chase
  CHASE_RET5_HARD_MAX: 1.90,      // hard chase cut
  CONFIRM_BREAK_PCT: 0.03,        // 0.03% above 20bar high
  CONFIRM_RET5_MAX: 1.20,

  // Trend confirmation (Long-only bias)
  REQUIRE_BULL_TREND: true,

  // Ranking smoothing + strongest lock
  SMOOTH_ALPHA: 0.22,            // new = a*now + (1-a)*prev
  STRONG_LOCK_MARGIN: 8,         // new #1 must exceed old #1 by >= 8 to replace

  // Gemini
  GEMINI_MODEL: "gemini-2.5-flash",
  GEMINI_ENDPOINT: "https://generativelanguage.googleapis.com/v1beta/models",
  MAX_OUTPUT_TOKENS: 420,
  TOPK_GEMINI: 3,
  GEMINI_MIN_INTERVAL_MS: 15000,   // global throttle
  GEMINI_AUTO_EVERY_MS: 120000,    // auto run every 2 min
  GEMINI_PER_SYMBOL_COOLDOWN_MS: 180000, // per symbol cooldown

  // Market cap exclusion
  MCAP_EXCLUDE_TOP_N: 25,
  COINGECKO_URL: "https://api.coingecko.com/api/v3/coins/markets",
  MCAP_CACHE_MS: 24 * 60 * 60 * 1000,
  MCAP_FALLBACK_TOP25: new Set([
    // fallback (approx) if CoinGecko blocked; safe to over-exclude
    "BTC","ETH","USDT","BNB","SOL","XRP","USDC","ADA","AVAX","DOGE","TRX","DOT","LINK","TON","SHIB",
    "LTC","BCH","UNI","ATOM","XLM","ICP","FIL","APT","NEAR","HBAR"
  ]),
};

const UI = {
  ledScan: document.getElementById("led-scan"),
  keyInput: document.getElementById("keyInput"),
  btnSaveKey: document.getElementById("btnSaveKey"),
  btnClearKey: document.getElementById("btnClearKey"),
  btnTestGemini: document.getElementById("btnTestGemini"),
  btnAnalyzeTop: document.getElementById("btnAnalyzeTop"),
  btnAuto: document.getElementById("btnAuto"),
  statusLine: document.getElementById("statusLine"),
  cards: document.getElementById("cards"),
  modelName: document.getElementById("modelName"),
  maxOut: document.getElementById("maxOut"),
  topK: document.getElementById("topK"),
  lastUpdate: document.getElementById("lastUpdate"),
  uCount: document.getElementById("uCount"),
  mcapStatus: document.getElementById("mcapStatus"),
  geminiStatus: document.getElementById("geminiStatus"),
  geminiRL: document.getElementById("geminiRL"),
};

UI.modelName.textContent = CFG.GEMINI_MODEL;
UI.maxOut.textContent = CFG.MAX_OUTPUT_TOKENS;
UI.topK.textContent = CFG.TOPK_GEMINI;

const S = {
  universe: [],
  idx: 0,
  stats: new Map(),        // symbol -> stats object
  top5: [],
  strongest: null,
  autoOn: false,

  // market cap exclusion
  mcapTopSet: new Set([...CFG.MCAP_FALLBACK_TOP25]),
  mcapLoaded: false,

  // gemini
  geminiKey: "",
  geminiQueueBusy: false,
  geminiLastCallAt: 0,
  geminiBackoffUntil: 0,
  gemini429Count: 0,
};

const LS = {
  KEY: "TRIDENT_GEMINI_KEY",
  MCAP_SET: "TRIDENT_MCAP_TOPSET",
  MCAP_TS: "TRIDENT_MCAP_TS",
};

/* ----------------- Utils ----------------- */
function nowStr() {
  const d = new Date();
  return d.toLocaleTimeString("zh-TW", { hour12:false });
}
function setLed(el, mode) {
  el.className = "led " + (mode==="on" ? "led-on" : mode==="warn" ? "led-warn" : mode==="bad" ? "led-bad" : "led-off");
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function fmtPct(x, d=2){ if (x===null||x===undefined||Number.isNaN(x)) return "-"; return (x>=0?"+":"") + x.toFixed(d) + "%"; }
function fmtNum(x, d=2){ if (x===null||x===undefined||Number.isNaN(x)) return "-"; return (+x).toFixed(d); }
function fmtInt(x){ if (x===null||x===undefined||Number.isNaN(x)) return "-"; return Math.round(x).toString(); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function median(arr){
  if(!arr.length) return NaN;
  const a=[...arr].sort((x,y)=>x-y);
  const m=Math.floor(a.length/2);
  return a.length%2? a[m] : (a[m-1]+a[m])/2;
}
function mean(arr){ return arr.reduce((s,v)=>s+v,0)/Math.max(1,arr.length); }
function stdev(arr){
  if(arr.length<2) return NaN;
  const m=mean(arr);
  const v=mean(arr.map(x=>(x-m)*(x-m)));
  return Math.sqrt(v);
}
function zscore(x, arr){
  if(arr.length<8) return NaN;
  const m=mean(arr), sd=stdev(arr);
  if(!sd || Number.isNaN(sd)) return NaN;
  return (x-m)/sd;
}
function ema(values, period){
  if(values.length<period) return { ema: NaN, slope: NaN };
  const k = 2/(period+1);
  let e = mean(values.slice(0,period));
  const start = e;
  for(let i=period; i<values.length; i++){
    e = values[i]*k + e*(1-k);
  }
  // rough slope: last - mid
  const midIdx = Math.max(0, values.length - Math.floor(period/2));
  let e2 = mean(values.slice(0,period));
  for(let i=period; i<midIdx; i++){
    e2 = values[i]*k + e2*(1-k);
  }
  return { ema: e, slope: e - e2 };
}
function baseAsset(sym){
  // sym like "1000SHIBUSDT" -> base "1000SHIB"
  let b = sym.replace("USDT","");
  // strip common Binance multipliers only (avoid 1INCH)
  if(/^1000/.test(b)) b = b.replace(/^1000/,"");
  if(/^10000/.test(b)) b = b.replace(/^10000/,"");
  if(/^100000/.test(b)) b = b.replace(/^100000/,"");
  return b;
}

/* -------- Robust JSON parse (Gemini sometimes wraps) -------- */
function safeParseJSON(s){
  if(!s) return null;
  s = String(s).replace(/```json/gi,"```").replace(/```/g,"").trim();
  const i = s.indexOf("{");
  if(i<0) return null;
  let depth=0;
  for(let k=i; k<s.length; k++){
    const ch=s[k];
    if(ch==="{") depth++;
    if(ch==="}") depth--;
    if(depth===0){
      const sub = s.slice(i,k+1);
      try { return JSON.parse(sub); } catch(e){ return null; }
    }
  }
  return null;
}

/* ----------------- Market Cap Exclusion ----------------- */
async function loadMarketCapTopSet(){
  // cache
  try{
    const ts = +localStorage.getItem(LS.MCAP_TS);
    const raw = localStorage.getItem(LS.MCAP_SET);
    if(raw && ts && (Date.now()-ts < CFG.MCAP_CACHE_MS)){
      const arr = JSON.parse(raw);
      S.mcapTopSet = new Set(arr);
      S.mcapLoaded = true;
      UI.mcapStatus.textContent = `å·²è¼‰å…¥(${arr.length})`;
      return;
    }
  }catch(e){}

  // fetch from CoinGecko
  try{
    const url = `${CFG.COINGECKO_URL}?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&sparkline=false`;
    const r = await fetch(url, { method:"GET" });
    if(!r.ok) throw new Error("coingecko "+r.status);
    const data = await r.json();
    const top = data.slice(0, CFG.MCAP_EXCLUDE_TOP_N).map(x => String(x.symbol||"").toUpperCase()).filter(Boolean);
    if(top.length >= 10){
      S.mcapTopSet = new Set(top);
      S.mcapLoaded = true;
      UI.mcapStatus.textContent = `å·²è¼‰å…¥(${top.length})`;
      try{
        localStorage.setItem(LS.MCAP_SET, JSON.stringify([...S.mcapTopSet]));
        localStorage.setItem(LS.MCAP_TS, String(Date.now()));
      }catch(e){}
      return;
    }
    throw new Error("coingecko insufficient data");
  }catch(e){
    // fallback
    S.mcapTopSet = new Set([...CFG.MCAP_FALLBACK_TOP25]);
    S.mcapLoaded = true;
    UI.mcapStatus.textContent = `å‚™æ´(${S.mcapTopSet.size})`;
  }
}

/* ----------------- Universe ----------------- */
async function refreshUniverse(){
  setLed(UI.ledScan, "warn");
  UI.statusLine.textContent = "status: refresh universeâ€¦";

  const url = `${CFG.BINANCE_FAPI}/fapi/v1/ticker/24hr`;
  const tickers = await fetch(url).then(r=>r.json());

  const filtered = tickers
    .filter(x => x.symbol && x.symbol.endsWith("USDT"))
    .filter(x => !CFG.EXCLUDE_SYMBOLS.has(x.symbol))
    .filter(x => +x.quoteVolume >= CFG.UNIVERSE_MIN_QV)
    .sort((a,b)=> (+b.quoteVolume) - (+a.quoteVolume))
    .slice(0, CFG.UNIVERSE_TOP_BY_QV)
    .map(x => x.symbol);

  // apply market-cap top25 exclusion
  const before = filtered.length;
  const after = filtered.filter(sym => !S.mcapTopSet.has(baseAsset(sym)));
  const excluded = before - after.length;

  S.universe = after;
  S.idx = 0;
  UI.uCount.textContent = `${S.universe.length} (æ’é™¤å¸‚å€¼Top25: -${excluded})`;
  UI.statusLine.textContent = `status: universe ready (${S.universe.length})`;
  setLed(UI.ledScan, "on");
}

/* ----------------- Binance data per symbol ----------------- */
async function fetchKlines(symbol){
  const url = `${CFG.BINANCE_FAPI}/fapi/v1/klines?symbol=${symbol}&interval=${CFG.KLINE_INTERVAL}&limit=${CFG.KLINE_LIMIT}`;
  return fetch(url).then(r=>r.json());
}
async function fetchPremiumIndex(symbol){
  const url = `${CFG.BINANCE_FAPI}/fapi/v1/premiumIndex?symbol=${symbol}`;
  return fetch(url).then(r=>r.json());
}
async function fetchOpenInterest(symbol){
  const url = `${CFG.BINANCE_FAPI}/fapi/v1/openInterest?symbol=${symbol}`;
  return fetch(url).then(r=>r.json());
}

function ensureStat(symbol){
  if(!S.stats.has(symbol)){
    S.stats.set(symbol, {
      symbol,
      price: NaN,
      ret5m: NaN,
      range20High: NaN,
      range20Low: NaN,
      toHighPct: NaN,

      volZ5: NaN,
      vol1mRatio: NaN,
      vol1mZ: NaN,
      volatilityZ: NaN,

      activeRatio1m: NaN,
      activeRatio5m: NaN,
      activeDiff1m: NaN,
      activeDiff5m: NaN,
      activeDiff4h: NaN,

      fundingRate: NaN,
      premiumPct: NaN,
      premiumZ: NaN,

      oiNow: NaN,
      oi5mChg: NaN,
      oi4hChg: NaN,
      oiZ5: NaN,
      oiHist: [],  // {t, oi}

      ema20: NaN,
      ema50: NaN,
      ema20Slope: NaN,
      trendOk: false,

      stage: "NONE", // SETUP/IGNITE/CONFIRM
      score: 0,
      scoreSmooth: 0,
      tags: [],

      ai: {
        lastAt: 0,
        status: "å°šæœªåˆ†æ",
        textZh: "",
        raw: "",
        err: "",
      }
    });
  }
  return S.stats.get(symbol);
}

function computeFromKlines(st, k){
  // parse arrays
  const closes = k.map(x => +x[4]);
  const highs  = k.map(x => +x[2]);
  const lows   = k.map(x => +x[3]);
  const qv     = k.map(x => +x[7]);  // quoteAssetVolume
  const tbq    = k.map(x => +x[10]); // takerBuyQuoteVolume

  const n = k.length;
  const close = closes[n-1];
  st.price = close;

  // ret5m
  if(n>=6){
    st.ret5m = (close - closes[n-6]) / closes[n-6] * 100;
  }

  // range20
  const win = 20;
  if(n>=win){
    const hs = highs.slice(n-win);
    const ls = lows.slice(n-win);
    st.range20High = Math.max(...hs);
    st.range20Low  = Math.min(...ls);
    st.toHighPct = (st.range20High - close) / close * 100; // distance to resistance (smaller=closer)
  }

  // active ratios/diffs
  const lastQ = qv[n-1];
  const lastTBQ = tbq[n-1];
  st.activeRatio1m = (lastQ>0) ? (lastTBQ/lastQ) : NaN;
  st.activeDiff1m  = (lastQ>0) ? (2*lastTBQ - lastQ) : NaN; // + means net taker buy

  // 5m sums
  if(n>=5){
    const q5 = qv.slice(n-5).reduce((s,v)=>s+v,0);
    const tb5 = tbq.slice(n-5).reduce((s,v)=>s+v,0);
    st.activeRatio5m = (q5>0) ? (tb5/q5) : NaN;
    st.activeDiff5m  = (q5>0) ? (2*tb5 - q5) : NaN;
  }

  // 4h sums
  const q4 = qv.reduce((s,v)=>s+v,0);
  const tb4 = tbq.reduce((s,v)=>s+v,0);
  st.activeDiff4h = (q4>0) ? (2*tb4 - q4) : NaN;

  // vol Z by 5m blocks (self-compare)
  if(n>=50){
    const blocks = [];
    for(let i=0; i+5<=n; i+=5){
      const sum = qv.slice(i,i+5).reduce((s,v)=>s+v,0);
      blocks.push(sum);
    }
    const last = blocks[blocks.length-1];
    const hist = blocks.slice(0,-1);
    st.volZ5 = zscore(last, hist);
  }

  // vol1m ratio vs median 20
  if(n>=21){
    const hist = qv.slice(n-21,n-1);
    const med = median(hist);
    st.vol1mRatio = (med>0) ? (qv[n-1]/med) : NaN;
    st.vol1mZ = zscore(qv[n-1], hist);
  }

  // volatility anomaly (ATR%-like) now vs baseline
  // ATR% (20) compared to baseline of previous 60
  if(n>=120){
    const tr = [];
    for(let i=n-20; i<n; i++){
      const rr = (highs[i]-lows[i]) / closes[i] * 100;
      tr.push(rr);
    }
    const cur = mean(tr);

    const baseArr = [];
    for(let j=n-120; j<=n-20; j+=5){
      const w = [];
      for(let i=j; i<j+20; i++){
        const rr = (highs[i]-lows[i]) / closes[i] * 100;
        w.push(rr);
      }
      baseArr.push(mean(w));
    }
    st.volatilityZ = zscore(cur, baseArr);
  }

  // trend (EMA20/50)
  const e20 = ema(closes, 20);
  const e50 = ema(closes, 50);
  st.ema20 = e20.ema; st.ema20Slope = e20.slope;
  st.ema50 = e50.ema;

  st.trendOk = (!!st.ema20 && !!st.ema50 && !Number.isNaN(st.ema20) && !Number.isNaN(st.ema50))
    ? (st.ema20 > st.ema50 && close >= st.ema20)
    : false;
}

function updateOIHistory(st, oiNow){
  const t = Date.now();
  st.oiNow = oiNow;
  st.oiHist.push({t, oi: oiNow});
  // keep last 6h
  const cutoff = t - 6*60*60*1000;
  while(st.oiHist.length && st.oiHist[0].t < cutoff) st.oiHist.shift();

  // compute 5m change / 4h change
  function findOlder(ms){
    const target = t - ms;
    // find nearest older sample
    for(let i=st.oiHist.length-1; i>=0; i--){
      if(st.oiHist[i].t <= target) return st.oiHist[i];
    }
    return null;
  }
  const o5 = findOlder(5*60*1000);
  const o4 = findOlder(4*60*60*1000);
  st.oi5mChg = o5 ? (oiNow - o5.oi) : NaN;
  st.oi4hChg = o4 ? (oiNow - o4.oi) : NaN;

  // oiZ5 based on history of 5m changes
  const diffs = [];
  for(let i=1;i<st.oiHist.length;i++){
    const dt = st.oiHist[i].t - st.oiHist[i-1].t;
    if(dt>3.5*60*1000 && dt<6.5*60*1000){
      diffs.push(st.oiHist[i].oi - st.oiHist[i-1].oi);
    }
  }
  st.oiZ5 = zscore(st.oi5mChg, diffs);
}

function computePremiumZ(st){
  // zscore premiumPct over last N stored in stat
  if(!st._premHist) st._premHist = [];
  if(!Number.isNaN(st.premiumPct)) st._premHist.push(st.premiumPct);
  if(st._premHist.length>120) st._premHist.shift();
  st.premiumZ = zscore(st.premiumPct, st._premHist.slice(0,-1));
}

function passLongOnlyFilter(st){
  // hard filters
  if(!Number.isNaN(st.ret5m) && st.ret5m > CFG.CHASE_RET5_HARD_MAX) return false;
  if(!Number.isNaN(st.ret5m) && st.ret5m < -0.15 && !(st.activeDiff5m>0)) return false;
  if(!Number.isNaN(st.toHighPct) && st.toHighPct > 0.60) return false;
  // anomaly-first: volatilityZ must be high enough to even consider
  if(!Number.isNaN(st.volatilityZ) && st.volatilityZ < CFG.VOLATILITY_Z_MIN) return false;
  return true;
}

function stageAndScore(st){
  st.tags = [];
  st.stage = "NONE";

  const volOK = (st.volZ5 >= CFG.VOLZ5_MIN);
  const buyOK = (st.activeDiff5m > 0) || (st.activeRatio5m >= CFG.ACTIVE_RATIO5_MIN);

  // Setup
  if(volOK && buyOK){
    st.stage = "SETUP";
    st.tags.push("ğŸŸ¨è“„å‹¢");
  }

  // Ignite (pre-break)
  const nearHigh = (!Number.isNaN(st.toHighPct) && st.toHighPct <= CFG.PREBREAK_TO_HIGH_MAX_PCT);
  const volRise = (!Number.isNaN(st.vol1mRatio) && st.vol1mRatio >= CFG.PREBREAK_VOL1M_RATIO_MIN) || (!Number.isNaN(st.vol1mZ) && st.vol1mZ >= 1.2);
  const buyPush = (st.activeDiff1m > 0 && st.activeDiff5m > 0);
  const retOK = (!Number.isNaN(st.ret5m) && st.ret5m >= CFG.PREBREAK_RET5_RANGE[0] && st.ret5m <= CFG.PREBREAK_RET5_RANGE[1]);

  if(st.stage==="SETUP" && nearHigh && volRise && buyPush && retOK){
    st.stage = "IGNITE";
    st.tags = ["ğŸŸ§é»ç«(çºŒåŠ›)"];
  }

  // Confirm (breakout)
  const broke = (!Number.isNaN(st.range20High) && st.price > st.range20High * (1 + CFG.CONFIRM_BREAK_PCT/100));
  const confirmRetOK = (!Number.isNaN(st.ret5m) && st.ret5m <= CFG.CONFIRM_RET5_MAX);
  const trendOK = CFG.REQUIRE_BULL_TREND ? st.trendOk : true;

  if((st.stage==="IGNITE" || st.stage==="SETUP") && broke && confirmRetOK && trendOK){
    st.stage = "CONFIRM";
    st.tags = ["ğŸŸ©è§¸ç™¼(å¯åŸ·è¡Œ)"];
  }

  // score (weights)
  let score = 0;

  // Base anomaly & bias
  score += (Number.isNaN(st.volZ5)?0: st.volZ5*6);
  score += (Number.isNaN(st.oiZ5)?0: Math.max(0, st.oiZ5)*3);
  score += (st.activeDiff5m>0 ? 5 : -7);
  score += (Number.isNaN(st.activeRatio5m)?0: (st.activeRatio5m - 0.5)*18);
  score += (CFG.REQUIRE_BULL_TREND ? (st.trendOk ? 5 : -5) : 0);
  score += (!Number.isNaN(st.ret5m) ? (st.ret5m>0 ? 2 : -5) : 0);

  // chase penalty
  if(!Number.isNaN(st.ret5m)){
    score -= Math.max(0, st.ret5m - 1.2) * 10;
  }

  // pre-break boost
  if(!Number.isNaN(st.toHighPct) && st.toHighPct <= CFG.PREBREAK_TO_HIGH_MAX_PCT){
    const nearHighBoost = ((CFG.PREBREAK_TO_HIGH_MAX_PCT - st.toHighPct) / CFG.PREBREAK_TO_HIGH_MAX_PCT) * 18;
    score += nearHighBoost;
  }
  if(!Number.isNaN(st.vol1mRatio)) score += Math.max(0, st.vol1mRatio - 1.0) * 6;
  if(!Number.isNaN(st.vol1mZ)) score += Math.max(0, st.vol1mZ) * 3;
  score += (st.activeDiff1m>0 ? 8 : -8);

  // stage bonus
  if(st.stage==="SETUP") score += 4;
  if(st.stage==="IGNITE") score += 12;
  if(st.stage==="CONFIRM") score += 18;

  // volatilityZ bonus (anomaly-first)
  if(!Number.isNaN(st.volatilityZ)) score += Math.max(0, st.volatilityZ) * 2;

  st.score = score;
  st.scoreSmooth = (st.scoreSmooth===0) ? score : (CFG.SMOOTH_ALPHA*score + (1-CFG.SMOOTH_ALPHA)*st.scoreSmooth);
}

/* ----------------- Scan loop ----------------- */
async function updateOne(symbol){
  const st = ensureStat(symbol);
  try{
    const [k, p, oi] = await Promise.all([
      fetchKlines(symbol),
      fetchPremiumIndex(symbol),
      fetchOpenInterest(symbol),
    ]);

    if(Array.isArray(k)) computeFromKlines(st, k);

    // premium / funding
    if(p && p.markPrice && p.indexPrice){
      const mark = +p.markPrice;
      const idx  = +p.indexPrice;
      st.fundingRate = +p.lastFundingRate * 100; // %
      st.premiumPct = (idx>0) ? ((mark-idx)/idx*100) : NaN;
      computePremiumZ(st);
    }

    // OI
    if(oi && oi.openInterest){
      updateOIHistory(st, +oi.openInterest);
    }

    // compute stage & score
    stageAndScore(st);

  }catch(e){
    // keep old
  }
}

function pickTop5(){
  const all = [...S.stats.values()]
    .filter(st => S.universe.includes(st.symbol))
    .filter(st => passLongOnlyFilter(st))
    .filter(st => st.price && !Number.isNaN(st.price));

  // prefer lit pool
  const lit = all.filter(st => st.stage !== "NONE");
  const pool = (lit.length>=5) ? lit : all;

  pool.sort((a,b)=> b.scoreSmooth - a.scoreSmooth);

  const top = pool.slice(0,5);

  // strongest lock
  if(!S.strongest && top.length){
    S.strongest = top[0].symbol;
  } else if(S.strongest && top.length){
    const curStrong = S.stats.get(S.strongest);
    const newTop = top[0];
    if(!curStrong){
      S.strongest = newTop.symbol;
    } else {
      // only replace if newTop exceeds old by margin
      if(newTop.symbol !== S.strongest && (newTop.scoreSmooth - curStrong.scoreSmooth) >= CFG.STRONG_LOCK_MARGIN){
        S.strongest = newTop.symbol;
      }
    }
  }

  // put strongest at top if exists
  const res = [];
  if(S.strongest){
    const sst = top.find(x=>x.symbol===S.strongest) || S.stats.get(S.strongest);
    if(sst) res.push(sst);
  }
  for(const x of top){
    if(!res.find(y=>y.symbol===x.symbol)) res.push(x);
  }
  S.top5 = res.slice(0,5);
}

/* ----------------- Rendering ----------------- */
function stageLabel(st){
  if(st.stage==="CONFIRM") return `<span class="pill pill-strong">ğŸŸ© è§¸ç™¼</span>`;
  if(st.stage==="IGNITE")  return `<span class="pill pill-warn">ğŸŸ§ é»ç«</span>`;
  if(st.stage==="SETUP")   return `<span class="pill">ğŸŸ¨ è“„å‹¢</span>`;
  return `<span class="pill pill-danger">â€”</span>`;
}

function metricRow(label, value){
  return `<div class="box flex items-center justify-between gap-3">
    <div class="k">${label}</div><div class="v mono">${value}</div>
  </div>`;
}

function aiBox(st){
  const a = st.ai || {};
  const title = `AI åˆ¤è®€ï¼ˆä¸­æ–‡ï¼‰`;
  const status = a.err ? `<span class="ai-r">å¤±æ•—</span>` : (a.textZh ? `<span class="ai-g">å·²æ›´æ–°</span>` : `<span class="muted">å°šæœªåˆ†æ</span>`);
  const body = a.textZh ? a.textZh : (a.err ? `<span class="ai-r">${escapeHtml(a.err).replace(/\n/g,"<br>")}</span>` : `<span class="muted">æŒ‰å³ä¸Šã€Geminiã€‘æˆ–ã€Analyze Topã€‘</span>`);

  return `
  <div class="box h-full">
    <div class="flex items-center justify-between mb-2">
      <div class="ai-title">${title}</div>
      <div class="small">${status}</div>
    </div>
    <div class="ai-line">${body}</div>
    ${a.raw ? `<div class="mt-2 small muted"><details><summary>RAW</summary><pre class="whitespace-pre-wrap text-[10px]">${escapeHtml(a.raw)}</pre></details></div>` : ""}
  </div>`;
}

function escapeHtml(s){
  return String(s||"").replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[c]));
}

function render(){
  UI.lastUpdate.textContent = nowStr();
  pickTop5();

  UI.cards.innerHTML = S.top5.map((st, idx)=>{
    const isStrong = (st.symbol===S.strongest);
    const rankClass = (idx===0 && isStrong) ? "rank1" : "";
    const pillStrong = isStrong ? `<span class="pill pill-strong">æœ€å¼·é–å®š</span>` : `<span class="pill">ç¬¬${idx+1}å</span>`;

    const needsOI5 = Number.isNaN(st.oi5mChg);
    const needsOI4 = Number.isNaN(st.oi4hChg);

    const oi5 = needsOI5 ? "ç†±æ©Ÿä¸­" : fmtNum(st.oi5mChg, 2);
    const oi4 = needsOI4 ? "ç†±æ©Ÿä¸­" : fmtNum(st.oi4hChg, 2);

    return `
    <div class="card p-3 ${rankClass}">
      <div class="flex items-start justify-between gap-3">
        <div class="flex flex-col gap-1">
          <div class="text-white font-black text-lg">${st.symbol.replace("USDT","")}</div>
          <div class="flex flex-wrap gap-2 items-center">
            ${pillStrong}
            ${stageLabel(st)}
            <span class="pill">score: <span class="ai-b">${fmtNum(st.scoreSmooth,2)}</span></span>
            <span class="pill">5mæ¼²è·Œ: <span class="ai-b">${fmtPct(st.ret5m,2)}</span></span>
          </div>
          <div class="text-[10px] muted">tags: ${st.tags.join(" ") || "-"}</div>
        </div>
        <div class="flex items-center gap-2">
          <button class="btn btn-blue nowrap" onclick="analyzeOne('${st.symbol}')">Gemini</button>
        </div>
      </div>

      <div class="grid-2 mt-3">
        <!-- LEFT: metrics -->
        <div class="flex flex-col gap-2">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
            ${metricRow("æ³¢å‹•ç•°å¸¸Z", fmtNum(st.volatilityZ,2))}
            ${metricRow("æˆäº¤é‡ç•°å¸¸Z(5m)", fmtNum(st.volZ5,2))}
            ${metricRow("1mé‡èƒ½å€ç‡", fmtNum(st.vol1mRatio,2))}
            ${metricRow("è·é›¢/å£“åŠ›(%)", Number.isNaN(st.toHighPct) ? "-" : fmtPct(-st.toHighPct,2).replace("+",""))}
            ${metricRow("ä¸»å‹•è²·å…¥æ¯”ä¾‹(1m)", fmtNum(st.activeRatio1m,3))}
            ${metricRow("ä¸»å‹•è²·å…¥æ¯”ä¾‹(5m)", fmtNum(st.activeRatio5m,3))}
            ${metricRow("ä¸»å‹•è²·å…¥å·®é¡(1m,USDT)", fmtInt(st.activeDiff1m))}
            ${metricRow("ä¸»å‹•è²·å…¥å·®é¡(5m,USDT)", fmtInt(st.activeDiff5m))}
            ${metricRow("OIè®ŠåŒ–(5m)", oi5)}
            ${metricRow("OIè®ŠåŒ–(4h)", oi4)}
            ${metricRow("OIç•°å¸¸Z(5m)", fmtNum(st.oiZ5,2))}
            ${metricRow("è³‡é‡‘è²»ç‡(%)", fmtNum(st.fundingRate,4))}
            ${metricRow("æº¢åƒ¹(æ¨™è¨˜-æŒ‡æ•¸)%", fmtNum(st.premiumPct,3))}
            ${metricRow("æº¢åƒ¹ç•°å¸¸Z", fmtNum(st.premiumZ,2))}
            ${metricRow("æ”¶æ–‚/è¶¨å‹¢(EMA20>EMA50)", st.trendOk ? "æ˜¯" : "å¦")}
            ${metricRow("é—œéµä½(20baré«˜)", Number.isNaN(st.range20High) ? "-" : fmtNum(st.range20High, 6))}
          </div>
          <div class="text-[10px] muted">
            * èªªæ˜ï¼šæ³¢å‹•/é‡èƒ½/è²·ç›¤/è²¼å£“åŠ› â†’ è§¸ç™¼ã€Œè“„å‹¢/é»ç«/è§¸ç™¼ã€ã€‚åªåšå¤šï¼Œæœƒè‡ªå‹• anti-chaseã€‚
          </div>
        </div>

        <!-- RIGHT: AI -->
        <div>
          ${aiBox(st)}
        </div>
      </div>
    </div>
    `;
  }).join("");

  UI.btnAuto.textContent = S.autoOn ? "ON" : "OFF";
  UI.btnAuto.className = "btn " + (S.autoOn ? "btn-green" : "");
}

/* ----------------- Gemini (structured JSON) ----------------- */
function loadKey(){
  try{
    const k = localStorage.getItem(LS.KEY) || "";
    S.geminiKey = k.trim();
    UI.keyInput.value = S.geminiKey ? S.geminiKey : "";
  }catch(e){}
}
function saveKey(){
  const k = (UI.keyInput.value||"").trim();
  S.geminiKey = k;
  try{ localStorage.setItem(LS.KEY, k); }catch(e){}
  UI.geminiStatus.textContent = k ? "KEY OK" : "æœªè¨­å®š";
}
function clearKey(){
  S.geminiKey = "";
  UI.keyInput.value = "";
  try{ localStorage.removeItem(LS.KEY); }catch(e){}
  UI.geminiStatus.textContent = "æœªè¨­å®š";
}

function buildGeminiPrompt(st){
  // concise summary (token-saving)
  const summary = {
    symbol: st.symbol,
    price: st.price,
    stage: st.stage,
    scoreSmooth: st.scoreSmooth,
    volatilityZ: st.volatilityZ,
    volZ5: st.volZ5,
    vol1mRatio: st.vol1mRatio,
    ret5m_pct: st.ret5m,
    toHighPct: st.toHighPct,
    activeRatio1m: st.activeRatio1m,
    activeRatio5m: st.activeRatio5m,
    activeDiff1m_usdt: st.activeDiff1m,
    activeDiff5m_usdt: st.activeDiff5m,
    oi5mChg: st.oi5mChg,
    oi4hChg: st.oi4hChg,
    oiZ5: st.oiZ5,
    fundingRate_pct: st.fundingRate,
    premiumPct: st.premiumPct,
    trendOk: st.trendOk,
    range20High: st.range20High,
    range20Low: st.range20Low,
  };

  return `
ä½ æ˜¯åˆç´„åšå¤šè¨Šè™Ÿåˆ†æå™¨ï¼Œåªèƒ½çµ¦ã€Œåšå¤šã€æˆ–ã€Œè§€æœ›/æ”¾æ£„ã€ã€‚
ç›®æ¨™ï¼šåœ¨çˆ†å™´å‰ 5~10 åˆ†é˜å…§ï¼Œææ—©æç¤ºã€Œå¯èƒ½è¡¨æ…‹ã€ï¼›ä½†è¦ anti-chaseï¼ˆé¿å…å·²å™´é«˜è¿½åƒ¹ï¼‰ã€‚
ä½ å¿…é ˆè¼¸å‡º *å–®ä¸€ JSON ç‰©ä»¶*ï¼Œä¸å¾—å¤¾å¸¶ä»»ä½•æ–‡å­—æˆ– markdownã€‚

äº¤æ˜“é¢¨æ ¼ï¼šåªåšå¤šã€åå‘ã€Œçªç ´å‰çºŒåŠ›(C æ¨¡å¼)ã€æˆ–ã€Œçªç ´å¾Œå›è¸©ã€ã€‚
è¼¸å…¥ç‚ºå‰ç«¯å·²ç®—å¥½çš„ç²¾ç°¡æŒ‡æ¨™ï¼ˆä¸ç”¨ä½ é‡ç®— K ç·šï¼‰ã€‚

è«‹è¼¸å‡ºä»¥ä¸‹æ¬„ä½ï¼š
- symbol
- verdictï¼ˆæ”¾æ£„/è§€å¯Ÿ/æº–å‚™/å¯åŸ·è¡Œï¼‰
- directionï¼ˆåšå¤š/è§€æœ›ï¼‰
- confidenceï¼ˆ0-100ï¼‰
- etaMinutes: {min, max}  // é è¨ˆå¹¾åˆ†é˜å…§è¡¨æ…‹å€é–“
- scoreï¼ˆ0-100ï¼‰          // ä½ ç¶œåˆå¾Œçš„åˆ†æ•¸
- entry: {type, price, note}
- stopLoss: {type, price, note}
- takeProfit: [{price, note}]
- invalidation: [string]
- reasons: [string]       // 3~6 é»
- risk: [string]          // 2~4 é»

è¦å‰‡ç´„æŸï¼š
- å¦‚æœ ret5m_pct > 1.2 æˆ– toHighPct å¾ˆå°ä½†å·²çªç ´å¤ªå¤šï¼Œå¿…é ˆé™ä½ä¿¡å¿ƒä¸¦æé†’è¿½é«˜é¢¨éšªã€‚
- è‹¥ stage=IGNITE/CONFIRM ä¸” activeDiff1m/5m ç‚ºæ­£ã€vol1mRatio ä¸Šå‡ã€è²¼è¿‘ range20Highï¼Œæ‰å¯çµ¦ã€Œæº–å‚™/å¯åŸ·è¡Œã€ã€‚
- price/entry/stopLoss/tp è«‹ç”¨æ•¸å­—ï¼ˆå¯å°æ•¸ï¼‰ï¼Œä¸è¦å­—ä¸²ã€‚

è¼¸å…¥æ‘˜è¦(JSON)ï¼š
${JSON.stringify(summary)}
`.trim();
}

function geminiSchema(){
  // Schema to force structured output (reduces "HTTP200 but not JSON") :contentReference[oaicite:1]{index=1}
  return {
    type: "object",
    properties: {
      symbol: { type: "string" },
      verdict: { type: "string" },
      direction: { type: "string" },
      confidence: { type: "integer" },
      etaMinutes: {
        type: "object",
        properties: {
          min: { type: "integer" },
          max: { type: "integer" }
        },
        required: ["min","max"]
      },
      score: { type: "integer" },
      entry: {
        type: "object",
        properties: {
          type: { type: "string" },
          price: { type: "number" },
          note: { type: "string" }
        },
        required: ["type","price","note"]
      },
      stopLoss: {
        type: "object",
        properties: {
          type: { type: "string" },
          price: { type: "number" },
          note: { type: "string" }
        },
        required: ["type","price","note"]
      },
      takeProfit: {
        type: "array",
        items: {
          type: "object",
          properties: {
            price: { type: "number" },
            note: { type: "string" }
          },
          required: ["price","note"]
        }
      },
      invalidation: { type: "array", items: { type: "string" } },
      reasons: { type: "array", items: { type: "string" } },
      risk: { type: "array", items: { type: "string" } }
    },
    required: ["symbol","verdict","direction","confidence","etaMinutes","score","entry","stopLoss","takeProfit","invalidation","reasons","risk"]
  };
}

function formatAIToZh(obj){
  const v = (x)=> (x===null||x===undefined) ? "-" : x;
  const lines = [];
  const dir = v(obj.direction);
  const verdict = v(obj.verdict);
  const conf = v(obj.confidence);
  const sc = v(obj.score);
  const eta = obj.etaMinutes ? `${v(obj.etaMinutes.min)}â€“${v(obj.etaMinutes.max)} åˆ†é˜` : "-";
  lines.push(`<div><span class="muted">æ–¹å‘ï¼š</span><span class="${dir.includes('åšå¤š')?'ai-g':'ai-w'}">${escapeHtml(dir)}</span> <span class="muted">ï½œç‹€æ…‹ï¼š</span><span class="ai-b">${escapeHtml(verdict)}</span> <span class="muted">ï½œä¿¡å¿ƒï¼š</span><span class="ai-b">${escapeHtml(conf)}/100</span></div>`);
  lines.push(`<div><span class="muted">é è¨ˆè¡¨æ…‹ï¼š</span><span class="ai-b">${escapeHtml(eta)}</span> <span class="muted">ï½œAIåˆ†æ•¸ï¼š</span><span class="ai-b">${escapeHtml(sc)}/100</span></div>`);

  if(obj.entry){
    lines.push(`<div class="mt-1"><span class="muted">é€²å ´ï¼š</span><span class="ai-b">${escapeHtml(obj.entry.type)}</span> @ <span class="ai-b">${escapeHtml(obj.entry.price)}</span><br><span class="muted">ã€€ã€€</span>${escapeHtml(obj.entry.note||"")}</div>`);
  }
  if(obj.stopLoss){
    lines.push(`<div class="mt-1"><span class="muted">åœæï¼š</span><span class="ai-b">${escapeHtml(obj.stopLoss.type)}</span> @ <span class="ai-b">${escapeHtml(obj.stopLoss.price)}</span><br><span class="muted">ã€€ã€€</span>${escapeHtml(obj.stopLoss.note||"")}</div>`);
  }
  if(Array.isArray(obj.takeProfit) && obj.takeProfit.length){
    const tps = obj.takeProfit.slice(0,3).map(tp => `@${tp.price}ï¼ˆ${tp.note}ï¼‰`).join("<br>");
    lines.push(`<div class="mt-1"><span class="muted">æ­¢ç›ˆï¼š</span><br>${tps}</div>`);
  }
  if(Array.isArray(obj.invalidation) && obj.invalidation.length){
    const inv = obj.invalidation.slice(0,4).map(x=>`â€¢ ${escapeHtml(x)}`).join("<br>");
    lines.push(`<div class="mt-2"><span class="ai-w">å¤±æ•ˆæ¢ä»¶ï¼š</span><br>${inv}</div>`);
  }
  if(Array.isArray(obj.reasons) && obj.reasons.length){
    const rs = obj.reasons.slice(0,6).map(x=>`â€¢ ${escapeHtml(x)}`).join("<br>");
    lines.push(`<div class="mt-2"><span class="ai-g">ç†ç”±è¦é»ï¼š</span><br>${rs}</div>`);
  }
  if(Array.isArray(obj.risk) && obj.risk.length){
    const rk = obj.risk.slice(0,4).map(x=>`â€¢ ${escapeHtml(x)}`).join("<br>");
    lines.push(`<div class="mt-2"><span class="ai-r">é¢¨éšªæé†’ï¼š</span><br>${rk}</div>`);
  }
  return lines.join("");
}

async function geminiCall(prompt){
  if(!S.geminiKey) return { ok:false, status:0, err:"æœªè¨­å®š Gemini Key" };

  const now = Date.now();
  if(now < S.geminiBackoffUntil){
    const sec = Math.ceil((S.geminiBackoffUntil - now)/1000);
    return { ok:false, status:429, err:`Gemini å†·å»ä¸­ï¼ˆ${sec}sï¼‰` };
  }

  const since = now - S.geminiLastCallAt;
  if(since < CFG.GEMINI_MIN_INTERVAL_MS){
    await sleep(CFG.GEMINI_MIN_INTERVAL_MS - since);
  }

  const url = `${CFG.GEMINI_ENDPOINT}/${CFG.GEMINI_MODEL}:generateContent?key=${encodeURIComponent(S.geminiKey)}`;

  const body = {
    contents: [{ role:"user", parts:[{ text: prompt }] }],
    generationConfig: {
      maxOutputTokens: CFG.MAX_OUTPUT_TOKENS,
      temperature: 0.25,
      responseMimeType: "application/json",
      responseSchema: geminiSchema(),
    },
  };

  try{
    S.geminiLastCallAt = Date.now();
    const r = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text();
    let data = null;
    try{ data = JSON.parse(txt); }catch(e){ /* keep raw */ }

    if(r.status===429){
      S.gemini429Count++;
      // backoff: 30s, 60s, 120s...
      const backoff = Math.min(240000, 30000 * Math.pow(2, Math.min(3, S.gemini429Count-1)));
      S.geminiBackoffUntil = Date.now() + backoff;
      UI.geminiRL.textContent = `429 x${S.gemini429Count}, backoff ${(backoff/1000)|0}s`;
      return { ok:false, status:429, err:"HTTP 429ï¼šè¶…éé…é¡/é€Ÿç‡é™åˆ¶", raw: txt };
    } else {
      S.gemini429Count = 0;
      UI.geminiRL.textContent = "-";
    }

    if(!r.ok){
      return { ok:false, status:r.status, err:`HTTP ${r.status}`, raw: txt };
    }

    // extract text parts robustly
    let out = "";
    try{
      const parts = data?.candidates?.[0]?.content?.parts || [];
      out = parts.map(p=>p.text).filter(Boolean).join("\n");
      if(!out) out = txt; // fallback
    }catch(e){
      out = txt;
    }

    const parsed = safeParseJSON(out) || safeParseJSON(txt);
    if(!parsed){
      return { ok:false, status:200, err:"HTTP 200 ä½† Gemini æ²’å›æœ‰æ•ˆ JSONï¼ˆå·²è¦æ±‚ JSON modeï¼‰", raw: out || txt };
    }
    return { ok:true, status:200, json: parsed, raw: out };
  }catch(e){
    return { ok:false, status:-1, err:"ç¶²è·¯éŒ¯èª¤/è¢«ç€è¦½å™¨é˜»æ“‹", raw:String(e) };
  }
}

async function analyzeOne(symbol){
  const st = S.stats.get(symbol);
  if(!st) return;

  // only analyze when "çºŒåŠ›/è§¸ç™¼"
  if(!(st.stage==="IGNITE" || st.stage==="CONFIRM")){
    st.ai.err = "æœªé”ã€çºŒåŠ›/è§¸ç™¼ã€ï¼Œä¸é€ AIï¼ˆé¿å…æµªè²»é…é¡ï¼‰";
    st.ai.raw = "";
    st.ai.textZh = "";
    render();
    return;
  }

  // cooldown
  const now = Date.now();
  if(now - st.ai.lastAt < CFG.GEMINI_PER_SYMBOL_COOLDOWN_MS){
    const sec = Math.ceil((CFG.GEMINI_PER_SYMBOL_COOLDOWN_MS - (now-st.ai.lastAt))/1000);
    st.ai.err = `æ­¤å¹£å†·å»ä¸­ï¼ˆ${sec}sï¼‰`;
    st.ai.raw = "";
    render();
    return;
  }

  st.ai.err = "";
  st.ai.raw = "";
  st.ai.textZh = "<span class='muted'>åˆ†æä¸­â€¦</span>";
  render();

  const res = await geminiCall(buildGeminiPrompt(st));
  st.ai.lastAt = Date.now();

  if(!res.ok){
    st.ai.err = `${res.err || "Gemini FAIL"} (HTTP ${res.status})`;
    st.ai.raw = res.raw || "";
    st.ai.textZh = "";
    UI.geminiStatus.textContent = `FAIL ${res.status}`;
    render();
    return;
  }

  const obj = res.json;
  st.ai.err = "";
  st.ai.raw = ""; // keep clean by default
  st.ai.textZh = formatAIToZh(obj);
  UI.geminiStatus.textContent = "OK";
  render();
}

async function analyzeTop(){
  // only take top candidates that are IGNITE/CONFIRM
  const list = S.top5
    .filter(st => st && (st.stage==="IGNITE" || st.stage==="CONFIRM"))
    .sort((a,b)=> b.scoreSmooth - a.scoreSmooth)
    .slice(0, CFG.TOPK_GEMINI);

  if(S.top5.length < 5){
    alert("Top5 æœªæ¹Šæ»¿ 5 æ”¯ï¼Œå…ˆç­‰æƒæå®Œæˆã€‚");
    return;
  }
  if(!list.length){
    alert("ç›®å‰æ²’æœ‰é”ã€çºŒåŠ›/è§¸ç™¼ã€çš„å¹£ï¼ŒAI ä¸æœƒé€å‡ºã€‚");
    return;
  }
  for(const st of list){
    await analyzeOne(st.symbol);
    await sleep(600); // small gap
  }
}

async function testGemini(){
  if(!S.geminiKey){
    alert("è«‹å…ˆè¼¸å…¥ä¸¦ Save Gemini Keyï¼ˆä¸è¦ commit åˆ° GitHubï¼‰ã€‚");
    return;
  }
  UI.geminiStatus.textContent = "TESTâ€¦";
  const prompt = `åªå›å–®ä¸€ JSONï¼š{"ok":true,"msg":"hello"}`;
  const res = await geminiCall(prompt);
  if(res.ok){
    UI.geminiStatus.textContent = "TEST OK";
    alert("Test Gemini OKï¼ˆæœ‰å› JSONï¼‰");
  }else{
    UI.geminiStatus.textContent = `TEST FAIL ${res.status}`;
    alert(`Test Gemini FAIL: ${res.err} (HTTP ${res.status})\nè«‹çœ‹ Console / æˆ–ç­‰ backoffã€‚`);
  }
}

/* ----------------- Scheduler ----------------- */
async function scanTick(){
  if(!S.universe.length) return;

  setLed(UI.ledScan, "on");

  const batch = [];
  for(let i=0;i<CFG.SCAN_BATCH_SIZE;i++){
    const sym = S.universe[S.idx % S.universe.length];
    S.idx++;
    batch.push(sym);
  }

  UI.statusLine.textContent = `status: scan batchâ€¦ (${batch[0]} â€¦)`;
  await Promise.all(batch.map(s => updateOne(s)));
  render();
}

async function autoLoop(){
  while(true){
    await sleep(1000);
    if(!S.autoOn) continue;

    // only run auto every 2 minutes
    if(!S._autoNextAt) S._autoNextAt = Date.now() + CFG.GEMINI_AUTO_EVERY_MS;
    if(Date.now() < S._autoNextAt) continue;

    // must have Top5 complete
    if(S.top5.length < 5){
      S._autoNextAt = Date.now() + 15000;
      continue;
    }

    // only if strongest is IGNITE/CONFIRM (çºŒåŠ›æ‰é€)
    const strong = S.stats.get(S.strongest);
    if(!strong || !(strong.stage==="IGNITE" || strong.stage==="CONFIRM")){
      S._autoNextAt = Date.now() + 20000;
      continue;
    }

    await analyzeTop();
    S._autoNextAt = Date.now() + CFG.GEMINI_AUTO_EVERY_MS;
  }
}

/* ----------------- UI events ----------------- */
UI.btnSaveKey.onclick = saveKey;
UI.btnClearKey.onclick = clearKey;
UI.btnTestGemini.onclick = testGemini;
UI.btnAnalyzeTop.onclick = analyzeTop;

UI.btnAuto.onclick = ()=>{
  S.autoOn = !S.autoOn;
  if(!S.autoOn) UI.geminiRL.textContent = "-";
  render();
};

UI.keyInput.addEventListener("keypress", (e)=>{
  if(e.key==="Enter") saveKey();
});

/* ----------------- Boot ----------------- */
(async function boot(){
  loadKey();
  UI.geminiStatus.textContent = S.geminiKey ? "KEY OK" : "æœªè¨­å®š";
  setLed(UI.ledScan, "warn");

  await loadMarketCapTopSet();
  await refreshUniverse();

  // periodically refresh universe
  setInterval(refreshUniverse, CFG.REFRESH_UNIVERSE_EVERY_MS);

  // scan loop
  await scanTick();
  setInterval(scanTick, CFG.SCAN_TICK_MS);

  // render loop (smooth UI)
  setInterval(render, 1000);

  // auto loop
  autoLoop();
})();
</script>

</body>
</html>
