<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRIDENT V7.4 - Long-only | Prefetch Klines + Anti-FallingKnife</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#050505; color:#d4d4d8; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .card { background:#0f0f11; border:1px solid #1f1f23; }
    .pill { border:1px solid #2a2a31; background:#0b0b0d; }
    .muted { color:#71717a; }
    .mono { font-variant-numeric: tabular-nums; }
    .badge { border:1px solid #2a2a31; background:#0b0b0d; padding:2px 8px; border-radius:999px; font-size:11px; }
    .locked { border:2px solid rgba(34,197,94,0.55) !important; box-shadow: 0 0 18px rgba(34,197,94,0.14); }
    .top1 { border:2px solid rgba(59,130,246,0.55) !important; box-shadow: 0 0 18px rgba(59,130,246,0.12); }
    .stage-setup { color:#f59e0b; border-color:#f59e0b !important; }
    .stage-ignite { color:#fb923c; border-color:#fb923c !important; }
    .stage-confirm{ color:#22c55e; border-color:#22c55e !important; }
    .btn { padding: 8px 12px; border-radius: 8px; font-size:12px; font-weight:800; }
    .btn-dark { background:#111115; border:1px solid #2a2a31; color:#cbd5e1; }
    .btn-dark:hover { background:#1a1a20; }
    .ok { color:#22c55e; }
    .bad { color:#ef4444; }
    .warn { color:#f59e0b; }
  </style>
</head>

<body class="p-4">

  <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between mb-4">
    <div class="flex items-center gap-3">
      <span id="hb" class="inline-block w-2 h-2 rounded-full bg-zinc-600"></span>
      <div>
        <div class="text-white font-black italic text-xl leading-none">
          TRIDENT <span class="text-emerald-400">V7.4</span> <span class="text-zinc-500 text-sm font-bold">LONG ONLY</span>
        </div>
        <div class="text-[11px] muted">
          âœ… Prefetch 1m Kç·š(60æ ¹) ç«‹å³è£œé½Šæ¬„ä½ï½œâœ… Top5 åªæ”¶ ğŸŸ¨/ğŸŸ§/ğŸŸ©ï½œâœ… Anti Falling Knife(è¶¨å‹¢æ¿¾ç¶²)
        </div>
        <div id="status" class="text-[11px] muted mono mt-1">status: -</div>
      </div>
    </div>

    <div class="flex gap-2 items-end">
      <button id="resetBtn" class="btn btn-dark">RESET</button>
    </div>
  </div>

  <div class="card rounded-lg p-4">
    <div class="flex items-center justify-between mb-3">
      <div class="text-white font-black">Top 5ï¼ˆå™´å‰å„ªå…ˆï¼šğŸŸ§é»ç« > ğŸŸ¨è“„å‹¢ > ğŸŸ©è§¸ç™¼ï¼‰</div>
      <div class="text-[11px] muted mono">
        æ›´æ–°ï¼š<span id="lastUpdate">-</span>
        Â· å‡çµï¼š<span id="freeze">-</span>
        Â· LOCKï¼š<span id="lockUI">-</span>
      </div>
    </div>
    <div id="top5" class="flex flex-col gap-3"></div>
  </div>

<script>
/* ========================= CONFIG ========================= */
const CFG = {
  EXCLUDE: new Set(['BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','BNBUSDT','BNXUSDT']),
  VOL_Z_TH: 1.6,
  FUND_Z_TH: 1.0,
  CANDIDATE_MAX: 40,
  WATCH_POOL_MAX: 12,

  // anti-chase / anti-dump
  MAX_RET_5M_PCT: 0.9,
  MIN_RET_5M_PCT: -0.35,          // å¼·è·Œç›´æ¥ä¸è¦
  MAX_ABS_PREMIUM_PCT: 0.25,

  ROBUST_MIN_HIST: 6,

  FLOW_BUCKET_MS: 3000,
  FLOW5M_MS: 5 * 60 * 1000,
  FLOW4H_MS: 4 * 60 * 60 * 1000,
  FLOW_SAMPLE_MS: 15000,
  FLOW_HIST_LEN: 240,

  OI_REFRESH_MS: 60_000,

  // stable ranking
  RANK_FREEZE_MS: 60_000,
  RANK_REPLACE_RATIO: 1.12,
  RANK_REPLACE_ABS: 0.8,

  // strongest lock
  LOCK_MIN_HOLD_MS: 90_000,
  LOCK_SWITCH_RATIO: 1.06,
  LOCK_SWITCH_ABS: 1.0,

  // stage lights
  STAGE: {
    SETUP: {
      TO_HIGH_MIN: 0.05, TO_HIGH_MAX: 0.80,
      RET5M_MIN: -0.20, RET5M_MAX: 0.40,
      IMB5M_MIN: 0.03,
      DELTA5M_POS: true,
      SQUEEZE_MIN: 0.70
    },
    IGNITE: {
      DELTAZ_MIN: 2.0,
      DELTAZ_VEL_MIN: 0.08,
      IMB5M_MIN: 0.08,
      VOL5MZ_MIN: 1.2,
      TO_HIGH_MIN: 0.03,
      RET5M_MAX: 0.60
    },
    CONFIRM: {
      VOL1M_RATIO_MIN: 2.0,
      CLOSE_ABOVE_HIGH_BP: 2,
      IMB5M_MIN: 0.05
    },
    HOLD_MS: { NONE:0, SETUP: 90_000, IGNITE: 120_000, CONFIRM: 180_000 }
  },

  // âœ… Prefetch klines to avoid "-"
  KLINE_PREFETCH_LIMIT: 60,
  KLINE_PREFETCH_COOLDOWN_MS: 180_000,
  KLINE_PREFETCH_CONCURRENCY: 4,
  KLINE_PREFETCH_DELAY_MS: 120,

  // âœ… Long-only filters (avoid falling knife)
  LONG_FLOW_IMB_MIN: 0.03,
  LONG_REQUIRE_TREND_OK: true,
  TREND: {
    EMA_FAST: 20,
    EMA_SLOW: 50,
    ABOVE_EMA_FAST_OK_BP: -5,     // close can be slightly below EMA20
    EMA_CROSS_OK: true,           // EMA20 >= EMA50
  },

  // âœ… OIâ†‘ + Priceâ†“ ban long
  BAN_OI_UP_PRICE_DOWN: true,
  BAN_OI_UP_RET5M_LT: -0.20,
};

const S = new Map();
let wsMark=null, wsAgg=null, wsK1m=null;
let symbolsAll=[];
let candidates=[], watchPool=[], watchPoolHash="";
let lastHeartbeat=0;

let pinnedTop5=[], pinnedUntil=0, lastTopAt=0;
let lockedSym=null, lockedAt=0;
let displayList=[];

/* ========================= UTILS ========================= */
class Ring {
  constructor(n){ this.n=n; this.a=[]; this.i=0; }
  push(x){ if(this.a.length<this.n) this.a.push(x); else { this.a[this.i]=x; this.i=(this.i+1)%this.n; } }
  values(){ if(this.a.length<this.n||this.i===0) return this.a.slice(); return this.a.slice(this.i).concat(this.a.slice(0,this.i)); }
  get size(){ return this.a.length; }
  last(){ if(!this.a.length) return null; if(this.a.length<this.n) return this.a[this.a.length-1]; const idx=(this.i-1+this.n)%this.n; return this.a[idx];}
}
function median(arr){ if(!arr.length) return 0; const a=arr.slice().sort((x,y)=>x-y); const m=Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2; }
function mad(arr, med){ if(!arr.length) return 0; const dev=arr.map(x=>Math.abs(x-med)); return median(dev); }
function robustZ(x, hist){ if(!hist||hist.length<CFG.ROBUST_MIN_HIST) return null; const med=median(hist); const m=(mad(hist, med)||1e-12); return (x-med)/(1.4826*m); }
function linSlope(y){ const n=y.length; if(n<6) return 0; let sx=0,sy=0,sxx=0,sxy=0; for(let i=0;i<n;i++){sx+=i;sy+=y[i];sxx+=i*i;sxy+=i*y[i];} const den=n*sxx-sx*sx; if(Math.abs(den)<1e-12) return 0; return (n*sxy-sx*sy)/den; }
function nowMs(){ return Date.now(); }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function fmt(x,d=3){ if(x===null||x===undefined||Number.isNaN(x)) return '-'; const v=Number(x); if(!Number.isFinite(v)) return '-'; return v.toFixed(d); }
function pct(x,d=2){ return fmt(x,d)+'%'; }
function fmtInt(x){ if(x===null||x===undefined||Number.isNaN(x)) return '-'; const v=Number(x); if(!Number.isFinite(v)) return '-'; return Math.round(v).toString(); }

function emaSeries(values, period){
  if(values.length<period) return null;
  const k = 2/(period+1);
  let e = values[0];
  for(let i=1;i<values.length;i++){ e = values[i]*k + e*(1-k); }
  return e;
}

/* ========================= FLOW WINDOW ========================= */
class BucketWindow {
  constructor(windowMs, bucketMs){ this.windowMs=windowMs; this.bucketMs=bucketMs; this.q=[]; this.sumBuy=0; this.sumSell=0; }
  _prune(now){ const minT=now-this.windowMs; while(this.q.length && this.q[0].t<minT){ const x=this.q.shift(); this.sumBuy-=x.buy; this.sumSell-=x.sell; } }
  push(ts, isTakerBuy, quote){
    const t=Math.floor(ts/this.bucketMs)*this.bucketMs;
    const qv=Number(quote)||0;
    const last=this.q[this.q.length-1];
    if(last && last.t===t){
      if(isTakerBuy){ last.buy+=qv; this.sumBuy+=qv; } else { last.sell+=qv; this.sumSell+=qv; }
    }else{
      const rec={t, buy:isTakerBuy?qv:0, sell:isTakerBuy?0:qv};
      this.q.push(rec);
      if(isTakerBuy) this.sumBuy+=qv; else this.sumSell+=qv;
    }
    this._prune(t);
  }
  snapshot(now){
    this._prune(now);
    const buy=this.sumBuy, sell=this.sumSell, vol=buy+sell;
    const delta=buy-sell, imb=vol>0?(delta/vol):0;
    return {buy,sell,vol,delta,imb};
  }
}

/* ========================= STATE ========================= */
function stOf(sym){
  if(S.has(sym)) return S.get(sym);
  const st = {
    sym,
    lastP:null, lastI:null,
    premRing:new Ring(100),
    retRing:new Ring(100),
    rvHist:new Ring(240),
    premSlopeHist:new Ring(240),
    lastSampleAt:0,
    ret5mPct:null, rv5m:null, premNow:null, premSlope:null, volZ:null, fundZ:null,

    flow5m:new BucketWindow(CFG.FLOW5M_MS, CFG.FLOW_BUCKET_MS),
    flow4h:new BucketWindow(CFG.FLOW4H_MS, 15000),
    flowHistVol:new Ring(CFG.FLOW_HIST_LEN),
    flowHistDelta:new Ring(CFG.FLOW_HIST_LEN),
    lastFlowSampleAt:0,
    vol5mQuote:null, delta5mQuote:null, imb5m:null,
    vol4hQuote:null, delta4hQuote:null, imb4h:null,
    vol5mZ:null, delta5mZ:null,

    k1m:[],
    kPrefetchedAt:0,
    levels:{swingHigh:null,swingLow:null,mid:null},
    dist:{toHighPct:null,toLowPct:null},
    squeezeScore:null, vol1mRatio:null, medRange1mPct:null,
    ema20:null, ema50:null, trendOk:null,

    oi:{ts:0, dOi5m:null, oi5mZ:null, dOi4h:null},

    score:null,
    stage:"NONE", stageScore:0, stageReason:"",
    stageSince:0, stageUntil:0,
    etaMin:null, etaMax:null,
    prevDeltaZ:null, prevDeltaZTs:0,
  };
  S.set(sym, st);
  return st;
}

/* ========================= BINANCE ========================= */
async function loadUniverse(){
  const ex = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo').then(r=>r.json());
  symbolsAll = (ex.symbols||[])
    .filter(x => x.status==='TRADING' && x.contractType==='PERPETUAL' && x.quoteAsset==='USDT')
    .map(x=>x.symbol)
    .filter(s => !CFG.EXCLUDE.has(s));
}

function connectMark(){
  if(wsMark) try{wsMark.close();}catch(_){}
  wsMark = new WebSocket('wss://fstream.binance.com/ws/!markPrice@arr');
  wsMark.onopen = ()=>{ lastHeartbeat=nowMs(); };
  wsMark.onmessage = (ev)=>{
    lastHeartbeat=nowMs();
    const arr = JSON.parse(ev.data);
    for(const u of arr){
      const sym=u.s;
      if(!sym || CFG.EXCLUDE.has(sym)) continue;
      const st=stOf(sym);
      const p=Number(u.p), i=Number(u.i);
      if(Number.isFinite(p) && st.lastP) st.retRing.push(Math.log(p/st.lastP));
      if(Number.isFinite(p)) st.lastP=p;
      if(Number.isFinite(i)) st.lastI=i;
      if(st.lastP && st.lastI) st.premRing.push((st.lastP-st.lastI)/st.lastI);
    }
  };
  wsMark.onclose = ()=>setTimeout(connectMark, 2000);
  wsMark.onerror = ()=>{ try{wsMark.close();}catch(_){} };
}

function sampleMarkMetrics(){
  const now=nowMs();
  for(const st of S.values()){
    if(st.retRing.size<20 || st.premRing.size<20) continue;
    const rets=st.retRing.values();
    let sum=0,sumsq=0;
    for(const x of rets){ sum+=x; sumsq+=x*x; }
    st.ret5mPct = (Math.exp(sum)-1)*100;
    st.rv5m = Math.sqrt(sumsq)*100;

    const prem=st.premRing.last();
    st.premNow = prem*100;
    st.premSlope = linSlope(st.premRing.values())*1e4;

    if(!st.lastSampleAt || (now-st.lastSampleAt>=60_000)){
      st.rvHist.push(st.rv5m);
      st.premSlopeHist.push(st.premSlope);
      st.lastSampleAt=now;
    }
    st.volZ = robustZ(st.rv5m, st.rvHist.values());
    st.fundZ = robustZ(st.premSlope, st.premSlopeHist.values());
  }
}

function computeCandidates(){
  const arr=[];
  for(const st of S.values()){
    if(st.volZ===null) continue;
    const volPass = Math.abs(st.volZ)>=CFG.VOL_Z_TH;
    const retPass = (st.ret5mPct!==null) && (st.ret5mPct<=CFG.MAX_RET_5M_PCT) && (st.ret5mPct>=CFG.MIN_RET_5M_PCT);
    const premPass = (st.premNow!==null) && (Math.abs(st.premNow)<=CFG.MAX_ABS_PREMIUM_PCT);
    if(!volPass || !retPass || !premPass) continue;

    const fundPass = (st.fundZ!==null) ? (Math.abs(st.fundZ)>=CFG.FUND_Z_TH) : false;
    const preScore = Math.abs(st.volZ) + 0.6*Math.abs(st.fundZ||0) + (fundPass?0.4:0);
    arr.push({sym:st.sym, preScore});
  }
  arr.sort((a,b)=>b.preScore-a.preScore);
  candidates = arr.slice(0, CFG.CANDIDATE_MAX).map(x=>x.sym);
  watchPool = arr.slice(0, CFG.WATCH_POOL_MAX).map(x=>x.sym);
}

/* ========================= Prefetch 1m klines ========================= */
async function prefetchOne(sym){
  const st = stOf(sym);
  const now = nowMs();
  if(st.k1m.length >= 20 && (now - st.kPrefetchedAt) < CFG.KLINE_PREFETCH_COOLDOWN_MS) return;
  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1m&limit=${CFG.KLINE_PREFETCH_LIMIT}`;
  const data = await fetch(url).then(r=>r.json());
  if(!Array.isArray(data)) return;
  st.k1m = data.map(k=>({
    t:Number(k[6]),
    o:Number(k[1]), h:Number(k[2]), l:Number(k[3]), c:Number(k[4]),
    v:Number(k[5])
  })).filter(b=>Number.isFinite(b.c));
  if(st.k1m.length > 60) st.k1m = st.k1m.slice(-60);
  st.kPrefetchedAt = now;
  computeStructureAndTags(st);
}

async function prefetchPool(){
  const pool = watchPool.slice();
  if(!pool.length) return;
  const q = pool.slice();
  const workers = [];
  for(let i=0;i<CFG.KLINE_PREFETCH_CONCURRENCY;i++){
    workers.push((async ()=>{
      while(q.length){
        const sym = q.shift();
        try{
          await prefetchOne(sym);
        }catch(_){}
        await new Promise(r=>setTimeout(r, CFG.KLINE_PREFETCH_DELAY_MS));
      }
    })());
  }
  await Promise.all(workers);
}

/* ========================= Streams for watchPool ========================= */
function connectAggForWatchPool(){
  const hash = watchPool.join('|');
  if(hash === watchPoolHash) return;
  watchPoolHash = hash;

  // prefetch klines immediately to fill "-"
  prefetchPool().catch(()=>{});

  if(wsAgg) try{wsAgg.close();}catch(_){}
  if(wsK1m) try{wsK1m.close();}catch(_){}
  if(!watchPool.length) return;

  const aggStreams = watchPool.map(s=>`${s.toLowerCase()}@aggTrade`);
  wsAgg = new WebSocket(`wss://fstream.binance.com/stream?streams=${aggStreams.join('/')}`);
  wsAgg.onmessage = (ev)=>{
    const msg=JSON.parse(ev.data);
    const d=msg.data;
    if(!d || d.e!=='aggTrade') return;
    const sym=d.s;
    const st=stOf(sym);
    const isTakerBuy = !d.m;
    const price=Number(d.p), qty=Number(d.q);
    const quote=price*qty;
    const ts=Number(d.T)||nowMs();
    st.flow5m.push(ts, isTakerBuy, quote);
    st.flow4h.push(ts, isTakerBuy, quote);
  };
  wsAgg.onclose = ()=>setTimeout(connectAggForWatchPool, 1500);
  wsAgg.onerror = ()=>{ try{wsAgg.close();}catch(_){} };

  const kStreams = watchPool.map(s=>`${s.toLowerCase()}@kline_1m`);
  wsK1m = new WebSocket(`wss://fstream.binance.com/stream?streams=${kStreams.join('/')}`);
  wsK1m.onmessage = (ev)=>{
    const msg=JSON.parse(ev.data);
    const data=msg.data;
    if(!data || data.e!=='kline') return;
    const sym=data.s;
    const k=data.k;
    if(!k || !k.x) return;
    const st=stOf(sym);
    const bar={ t:Number(k.T), o:Number(k.o), h:Number(k.h), l:Number(k.l), c:Number(k.c), v:Number(k.v) };
    st.k1m.push(bar);
    if(st.k1m.length>60) st.k1m.shift();
    computeStructureAndTags(st);
  };
  wsK1m.onclose = ()=>setTimeout(connectAggForWatchPool, 1500);
  wsK1m.onerror = ()=>{ try{wsK1m.close();}catch(_){} };
}

function sampleFlow(){
  const now=nowMs();
  for(const sym of watchPool){
    const st=stOf(sym);
    if(now-st.lastFlowSampleAt < CFG.FLOW_SAMPLE_MS) continue;
    const s5=st.flow5m.snapshot(now);
    const s4=st.flow4h.snapshot(now);
    st.vol5mQuote=s5.vol;
    st.delta5mQuote=s5.delta;
    st.imb5m=s5.imb;
    st.vol4hQuote=s4.vol;
    st.delta4hQuote=s4.delta;
    st.imb4h=s4.imb;

    st.flowHistVol.push(st.vol5mQuote);
    st.flowHistDelta.push(st.delta5mQuote);
    st.vol5mZ = robustZ(st.vol5mQuote, st.flowHistVol.values());
    st.delta5mZ = robustZ(st.delta5mQuote, st.flowHistDelta.values());
    st.lastFlowSampleAt=now;
  }
}

/* ========================= Structure / Trend ========================= */
function computeStructureAndTags(st){
  const bars=st.k1m;
  if(bars.length<20) return;

  const seg=bars.slice(-20);
  const swingHigh=Math.max(...seg.map(b=>b.h));
  const swingLow=Math.min(...seg.map(b=>b.l));
  st.levels.swingHigh=swingHigh;
  st.levels.swingLow=swingLow;
  st.levels.mid=(swingHigh+swingLow)/2;

  const p = st.lastP ?? seg[seg.length-1].c;
  st.dist.toHighPct=(swingHigh-p)/p*100;
  st.dist.toLowPct=(p-swingLow)/p*100;

  // squeeze score + vol ratio + med range
  const ranges10 = seg.slice(-10).map(b=>(b.h-b.l)/Math.max(1e-12,b.c));
  const medR = median(seg.map(b=>(b.h-b.l)/Math.max(1e-12,b.c)));
  const smallCount = ranges10.filter(x=>x < 0.8*medR).length;
  st.squeezeScore = smallCount/10;

  const vols = seg.map(b=>b.v);
  const medV = median(vols) || 1e-12;
  st.vol1mRatio = seg[seg.length-1].v / medV;

  const rangePct = seg.map(b=>(b.h-b.l)/Math.max(1e-12,b.c)*100);
  st.medRange1mPct = median(rangePct);

  // EMA trend
  const closes = bars.slice(-60).map(b=>b.c);
  st.ema20 = emaSeries(closes.slice(-60), CFG.TREND.EMA_FAST);
  st.ema50 = emaSeries(closes.slice(-60), CFG.TREND.EMA_SLOW);

  const lastC = closes[closes.length-1];
  const emaOk = (st.ema20 && lastC) ? (lastC >= st.ema20 * (1 + CFG.TREND.ABOVE_EMA_FAST_OK_BP/10000)) : false;
  const crossOk = (st.ema20 && st.ema50) ? (st.ema20 >= st.ema50) : false;
  st.trendOk = CFG.TREND.EMA_CROSS_OK ? (emaOk || crossOk) : emaOk;
}

/* ========================= OI ========================= */
async function fetchOI(sym){
  const st=stOf(sym);
  const now=nowMs();
  if(now-st.oi.ts < CFG.OI_REFRESH_MS) return;

  const url5=`https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=5m&limit=50`;
  const url4=`https://fapi.binance.com/futures/data/openInterestHist?symbol=${sym}&period=4h&limit=2`;
  const [d5,d4] = await Promise.all([
    fetch(url5).then(r=>r.json()).catch(()=>null),
    fetch(url4).then(r=>r.json()).catch(()=>null),
  ]);

  function sortByTs(a){ return (a||[]).slice().sort((x,y)=>(x.timestamp||0)-(y.timestamp||0)); }

  const a5=sortByTs(d5);
  if(a5.length>=10){
    const series=a5.map(x=>Number(x.sumOpenInterestValue ?? x.sumOpenInterest));
    const diffs=[];
    for(let i=1;i<series.length;i++) diffs.push(series[i]-series[i-1]);
    const lastDiff=diffs[diffs.length-1];
    const hist=diffs.slice(0,-1);
    st.oi.dOi5m=lastDiff;
    st.oi.oi5mZ=robustZ(lastDiff, hist);
  }

  const a4=sortByTs(d4);
  if(a4.length===2){
    const s0=Number(a4[0].sumOpenInterestValue ?? a4[0].sumOpenInterest);
    const s1=Number(a4[1].sumOpenInterestValue ?? a4[1].sumOpenInterest);
    st.oi.dOi4h=(s1-s0);
  }
  st.oi.ts=now;
}
async function refreshOI(){
  for(const sym of watchPool){
    try{ await fetchOI(sym); }catch(_){}
  }
}

/* ========================= Stage + ETA ========================= */
function estimateETA(st){
  const dist=st.dist?.toHighPct, base=st.medRange1mPct;
  if(dist===null||base===null||base===undefined) return {min:null,max:null};
  const dz=clamp(st.delta5mZ||0,0,4);
  const speed=Math.max(0.02, base*(1+0.35*dz));
  const eta=clamp(dist/speed,1,15);
  if(st.stage==="IGNITE") return {min:Math.max(1,Math.floor(eta*0.6)), max:Math.min(8,Math.ceil(eta*1.2))};
  if(st.stage==="SETUP")  return {min:Math.max(2,Math.floor(eta*0.8)), max:Math.min(15,Math.ceil(eta*1.6))};
  if(st.stage==="CONFIRM")return {min:0, max:Math.min(3,Math.ceil(eta*0.8))};
  return {min:null,max:null};
}
function stagePriority(stage){ return ({IGNITE:3, SETUP:2, CONFIRM:1, NONE:0}[stage] ?? 0); }
function setStage(st, stage, score, reason){
  const now=nowMs();
  if(st.stage!==stage){ st.stage=stage; st.stageSince=now; }
  st.stageScore=score; st.stageReason=reason;
  st.stageUntil = now + (CFG.STAGE.HOLD_MS[stage]||0);
  const eta=estimateETA(st); st.etaMin=eta.min; st.etaMax=eta.max;
}

function computeStage(st){
  const now=nowMs();
  const stillHold = st.stage!=="NONE" && now < (st.stageUntil||0);

  // ban: OI up + price down
  if(CFG.BAN_OI_UP_PRICE_DOWN){
    if((st.oi.dOi5m||0) > 0 && (st.ret5mPct||0) < CFG.BAN_OI_UP_RET5M_LT){
      if(!stillHold) setStage(st, "NONE", 0, "ç¦å¤šï¼šOIâ†‘ä¸”5mè·Œï¼ˆç–‘ä¼¼åŠ é€Ÿä¸‹è·Œ/èª˜å¤šï¼‰");
      return;
    }
  }

  const toHigh=st.dist?.toHighPct;
  const ret5m=st.ret5mPct;
  const imb5m=st.imb5m;
  const d5=st.delta5mQuote;
  const dz=st.delta5mZ;
  const vz=st.vol5mZ;

  // deltaZ velocity
  let dzVel=0;
  if(st.prevDeltaZ!==null && st.prevDeltaZTs){
    const dt=Math.max(1,(now-st.prevDeltaZTs)/1000);
    dzVel=((dz||0)-(st.prevDeltaZ||0))/dt;
    dzVel=dzVel*15;
  }
  st.prevDeltaZ=(dz||0);
  st.prevDeltaZTs=now;

  // CONFIRM
  const bars=st.k1m||[];
  const lastBar=bars.length?bars[bars.length-1]:null;
  const high=st.levels?.swingHigh;
  const closeAbove=(lastBar&&high)?(lastBar.c > high*(1+(CFG.STAGE.CONFIRM.CLOSE_ABOVE_HIGH_BP/10000))):false;
  const volOk=(st.vol1mRatio||0)>=CFG.STAGE.CONFIRM.VOL1M_RATIO_MIN;
  const flowOkC=(imb5m||0)>=CFG.STAGE.CONFIRM.IMB5M_MIN && (d5||0)>0;
  if(closeAbove && volOk && flowOkC){
    const score=100+(dz||0)+0.5*(vz||0);
    setStage(st,"CONFIRM",score,"1mæ”¶ç·šçªç ´å£“åŠ›ä¸”æ”¾é‡ï¼Œflowåå¤š");
    return;
  }

  // IGNITE
  const ign=CFG.STAGE.IGNITE;
  const ignOK=(dz||0)>=ign.DELTAZ_MIN && (dzVel||0)>=ign.DELTAZ_VEL_MIN &&
              (imb5m||0)>=ign.IMB5M_MIN && (vz||0)>=ign.VOL5MZ_MIN &&
              (toHigh!==null && toHigh>=ign.TO_HIGH_MIN) &&
              (ret5m===null || ret5m<=ign.RET5M_MAX);
  if(ignOK){
    const score=70+2*(dz||0)+0.6*(vz||0)+10*(imb5m||0);
    setStage(st,"IGNITE",score,"ä¸»å‹•è²·å…¥å·®é¡åŠ é€Ÿä¸Šå‡ï¼Œé‡èƒ½ç•°å¸¸ï¼Œå°šæœªçªç ´");
    return;
  }

  // SETUP
  const su=CFG.STAGE.SETUP;
  const squeezeOk=(st.squeezeScore||0)>=su.SQUEEZE_MIN;
  const toHighOk=(toHigh!==null)&&(toHigh>=su.TO_HIGH_MIN && toHigh<=su.TO_HIGH_MAX);
  const retOk=(ret5m!==null)?(ret5m>=su.RET5M_MIN && ret5m<=su.RET5M_MAX):false;
  const flowOk=(imb5m||0)>=su.IMB5M_MIN && ((su.DELTA5M_POS && (d5||0)>0) || !su.DELTA5M_POS);
  if(squeezeOk && toHighOk && retOk && flowOk){
    const score=40+(st.volZ||0)+0.5*(st.fundZ||0)+8*(imb5m||0);
    setStage(st,"SETUP",score,"æ”¶æ–‚æ“ å£“ + é è¿‘å£“åŠ› + ä¸»å‹•è²·å…¥å †ç©ï¼ˆæœªå™´ï¼‰");
    return;
  }

  if(!stillHold) setStage(st,"NONE",0,"");
}

/* ========================= Long-only filter ========================= */
function passLongOnly(st){
  // base: flow positive
  const flowOk = (st.imb5m!==null && st.delta5mQuote!==null) &&
                 (st.imb5m > CFG.LONG_FLOW_IMB_MIN) &&
                 (st.delta5mQuote > 0);
  if(!flowOk) return false;

  // anti-chase / anti-dump
  if(st.ret5mPct!==null && (st.ret5mPct > CFG.MAX_RET_5M_PCT || st.ret5mPct < CFG.MIN_RET_5M_PCT)) return false;
  if(st.premNow!==null && Math.abs(st.premNow) > CFG.MAX_ABS_PREMIUM_PCT) return false;

  // trend filter (avoid falling knife)
  if(CFG.LONG_REQUIRE_TREND_OK){
    if(st.trendOk === false) return false;
    // if trendOk is null (not ready), also reject => prevent garbage early
    if(st.trendOk === null || st.trendOk === undefined) return false;
  }

  return true;
}

/* ========================= Ranking + Lock ========================= */
function updateRank(){
  const rows=[];
  for(const sym of watchPool){
    const st=stOf(sym);
    if(st.volZ===null) continue;
    computeStage(st);

    // âœ… only show stage not NONE
    if(st.stage==="NONE") continue;

    if(!passLongOnly(st)) continue;

    const score=st.stageScore||0;
    st.score=score;
    rows.push({sym, score});
  }

  rows.sort((a,b)=>{
    const pa=stagePriority(stOf(a.sym).stage);
    const pb=stagePriority(stOf(b.sym).stage);
    if(pb!==pa) return pb-pa;
    return b.score-a.score;
  });

  const now=nowMs();
  const top1=rows[0]||null;
  if(!lockedSym && top1){ lockedSym=top1.sym; lockedAt=now; }
  else if(lockedSym && top1){
    const lockedRow=rows.find(x=>x.sym===lockedSym);
    if(!lockedRow){ lockedSym=top1.sym; lockedAt=now; }
    else if(top1.sym!==lockedSym){
      const holdOk=(now-lockedAt)>=CFG.LOCK_MIN_HOLD_MS;
      const ratioOk=top1.score>lockedRow.score*CFG.LOCK_SWITCH_RATIO;
      const absOk=top1.score>lockedRow.score+CFG.LOCK_SWITCH_ABS;
      if(holdOk && (ratioOk||absOk)){ lockedSym=top1.sym; lockedAt=now; }
    }
  }

  const desired=[];
  if(lockedSym){
    const lr=rows.find(x=>x.sym===lockedSym);
    if(lr) desired.push(lr.sym);
  }
  for(const r of rows){
    if(desired.length>=5) break;
    if(!desired.includes(r.sym)) desired.push(r.sym);
  }

  const frozen=now<pinnedUntil;
  if(!pinnedTop5.length || !frozen){
    pinnedTop5=desired.slice(0,5);
    pinnedUntil=now+CFG.RANK_FREEZE_MS;
  }else{
    const current=pinnedTop5.slice(0,5);
    const scoreMap=new Map(rows.map(x=>[x.sym,x.score]));
    const weakestSym=current.slice().sort((a,b)=>(scoreMap.get(a)||-999)-(scoreMap.get(b)||-999))[0];
    const weakestScore=scoreMap.get(weakestSym)??-999;

    if(lockedSym && !current.includes(lockedSym)) current[0]=lockedSym;

    for(const cand of desired){
      if(current.includes(cand)) continue;
      const cs=scoreMap.get(cand)??-999;
      const ratioOk=cs>weakestScore*CFG.RANK_REPLACE_RATIO;
      const absOk=cs>weakestScore+CFG.RANK_REPLACE_ABS;
      if(ratioOk||absOk){
        const idx=current.indexOf(weakestSym);
        if(idx!==-1) current[idx]=cand;
        break;
      }
    }
    pinnedTop5=current;
  }

  const scoreMap=new Map(rows.map(x=>[x.sym,x.score]));
  displayList=pinnedTop5.map(sym=>({sym, score:scoreMap.get(sym)??0})).filter(x=>x.sym);

  lastTopAt=now;
  document.getElementById('lastUpdate').innerText=new Date(lastTopAt).toLocaleTimeString();
}

/* ========================= UI ========================= */
function stageBadgeHtml(st){
  if(st.stage==="SETUP")  return `<span class="badge stage-setup">ğŸŸ¨ è“„å‹¢</span>`;
  if(st.stage==="IGNITE") return `<span class="badge stage-ignite">ğŸŸ§ é»ç«</span>`;
  if(st.stage==="CONFIRM")return `<span class="badge stage-confirm">ğŸŸ© è§¸ç™¼</span>`;
  return `<span class="badge muted">â€”</span>`;
}

function render(){
  const alive=(nowMs()-lastHeartbeat)<5000;
  document.getElementById('hb').className=`inline-block w-2 h-2 rounded-full ${alive?'bg-emerald-500':'bg-zinc-600'}`;

  const now=nowMs();
  const freezeLeft=Math.max(0,pinnedUntil-now);
  document.getElementById('freeze').innerText=pinnedTop5.length?`${Math.ceil(freezeLeft/1000)}s`:"-";
  document.getElementById('lockUI').innerText=lockedSym?`${lockedSym} (${Math.floor((now-lockedAt)/1000)}s)`:"-";

  const zReady=[...S.values()].filter(x=>x.volZ!==null).length;
  document.getElementById('status').innerText =
    `universe=${symbolsAll.length} | states=${S.size} | zReady=${zReady} | candidates=${candidates.length} | watch=${watchPool.length} | show=${displayList.length}`;

  const wrap=document.getElementById('top5');
  wrap.innerHTML="";

  if(!displayList.length){
    wrap.innerHTML = `<div class="text-[12px] muted">ç›®å‰æ²’æœ‰ç¬¦åˆ ğŸŸ¨/ğŸŸ§/ğŸŸ© ä¸”é€šéã€Œååˆ€æ¿¾ç¶²ã€çš„å¹£ã€‚é€™æ˜¯æ­£å¸¸çš„ï¼ˆä¸ç¡¬é¸åƒåœ¾ï¼‰ã€‚</div>`;
    return;
  }

  for(let i=0;i<displayList.length;i++){
    const row=displayList[i];
    const sym=row.sym;
    const st=stOf(sym);

    const isLocked=(sym===lockedSym);
    const isTop1=(i===0);

    const badges=[];
    if(isLocked) badges.push(`<span class="badge ok">ğŸ¯ æœ€å¼·é–å®š</span>`);
    if(isTop1) badges.push(`<span class="badge" style="color:#60a5fa;border-color:#60a5fa;">ğŸ† ç¬¬1å</span>`);
    badges.push(stageBadgeHtml(st));
    if(st.etaMin!==null && st.etaMax!==null) badges.push(`<span class="badge text-zinc-200">ETA ${st.etaMin}~${st.etaMax}m</span>`);
    if(st.stageReason) badges.push(`<span class="badge muted">${st.stageReason}</span>`);
    badges.push(`<span class="badge muted">score ${fmt(row.score,2)}</span>`);

    const card=document.createElement('div');
    card.className=`p-3 rounded-lg border border-zinc-800 bg-black/20 ${isLocked?'locked':''} ${isTop1?'top1':''}`;

    card.innerHTML=`
      <div class="text-white font-black text-lg">${sym}</div>
      <div class="text-[11px] muted mono mt-1">${badges.join(" ")}</div>

      <div class="grid grid-cols-2 md:grid-cols-3 gap-2 mt-3 text-[11px] mono">
        <div class="pill rounded px-2 py-1">æ³¢å‹•ç•°å¸¸Zï¼š<span class="text-white">${fmt(st.volZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">è³‡è²»æ–œç‡Zï¼š<span class="text-white">${fmt(st.fundZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">5åˆ†é˜æ¼²è·Œï¼š<span class="text-white">${pct(st.ret5mPct,2)}</span></div>

        <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥æ¯”ä¾‹(5m)ï¼š<span class="text-white">${fmt(st.imb5m,3)}</span></div>
        <div class="pill rounded px-2 py-1">ä¸»å‹•è²·å…¥å·®é¡(5m)ï¼š<span class="text-white">${fmtInt(st.delta5mQuote)}</span></div>
        <div class="pill rounded px-2 py-1">å·®é¡ç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.delta5mZ,2)}</span></div>

        <div class="pill rounded px-2 py-1">æˆäº¤é‡ç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.vol5mZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">OIç•°å¸¸Z(5m)ï¼š<span class="text-white">${fmt(st.oi.oi5mZ,2)}</span></div>
        <div class="pill rounded px-2 py-1">OIè®ŠåŒ–(4h)ï¼š<span class="text-white">${fmt(st.oi.dOi4h,2)}</span></div>

        <div class="pill rounded px-2 py-1">æ”¶æ–‚åˆ†æ•¸(æ“ å£“)ï¼š<span class="text-white">${fmt(st.squeezeScore,2)}</span></div>
        <div class="pill rounded px-2 py-1">1mé‡èƒ½å€ç‡ï¼š<span class="text-white">${fmt(st.vol1mRatio,2)}</span></div>
        <div class="pill rounded px-2 py-1">è·é«˜/ä½é»(%)ï¼š<span class="text-white">${fmt(st.dist.toHighPct,2)}/${fmt(st.dist.toLowPct,2)}</span></div>

        <div class="pill rounded px-2 py-1">EMA20ï¼š<span class="text-white">${fmt(st.ema20,6)}</span></div>
        <div class="pill rounded px-2 py-1">EMA50ï¼š<span class="text-white">${fmt(st.ema50,6)}</span></div>
        <div class="pill rounded px-2 py-1">è¶¨å‹¢æ¿¾ç¶²ï¼š<span class="${st.trendOk?'ok':'bad'} font-bold">${st.trendOk?'OK':'NO'}</span></div>

        <div class="pill rounded px-2 py-1">é—œéµä½(1m-20)ï¼š<span class="text-white">${fmt(st.levels.swingLow,6)} ~ ${fmt(st.levels.swingHigh,6)}</span></div>
        <div class="pill rounded px-2 py-1">ä¸­ä½(mid)ï¼š<span class="text-white">${fmt(st.levels.mid,6)}</span></div>
        <div class="pill rounded px-2 py-1">æº¢åƒ¹(æ¨™è¨˜-æŒ‡æ•¸)ï¼š<span class="text-white">${pct(st.premNow,3)}</span></div>
      </div>
    `;
    wrap.appendChild(card);
  }
}

/* ========================= PIPELINE ========================= */
async function pipelineTick(){
  computeCandidates();
  connectAggForWatchPool();
  sampleFlow();
  await refreshOI();

  for(const sym of watchPool){
    computeStage(stOf(sym));
  }
  updateRank();
}

/* ========================= BOOT ========================= */
document.getElementById('resetBtn').onclick=()=>location.reload();

(async function main(){
  await loadUniverse();
  connectMark();

  setInterval(sampleMarkMetrics, 1000);
  setInterval(render, 1000);
  setInterval(()=>{ pipelineTick().catch(()=>{}); }, 10_000);
})();
</script>

</body>
</html>
